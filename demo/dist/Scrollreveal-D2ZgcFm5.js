import{B as e}from"./index.esm-DNh4gpcb.js";class t extends e{_getSelector(){return"data-scrollreveal"}static get defaults(){return{threshold:.1,rootMargin:"0px",once:!0,delay:0,stagger:100,initialState:"hidden"}}constructor(e={}){super(e),this.transitionManager=e.transitionManager,this.revealQueue=[],this.isProcessingQueue=!1,this._createObserver()}_createObserver(){const e={root:null,rootMargin:t.defaults.rootMargin,threshold:t.defaults.threshold};this.observer=new IntersectionObserver(this._handleIntersection.bind(this),e),this.logger?.info("Scrollreveal intersection observer created",e)}_init(e){const s=super._init(e),r=this.getAttr(e,"threshold",t.defaults.threshold),a=this.getAttr(e,"once",t.defaults.once),i=this.getAttr(e,"delay",t.defaults.delay),n=this.getAttr(e,"stagger",t.defaults.stagger),l=this.getAttr(e,"initial",t.defaults.initialState);s.threshold=parseFloat(r),s.once=Boolean(a),s.delay=parseInt(i,10),s.stagger=parseInt(n,10),s.initialState=l,s.hasBeenRevealed=!1,s.isRevealing=!1,s.items=[e],this._setInitialState(e,s),e.setAttribute("data-scrollreveal-enhanced","true"),s.threshold!==t.defaults.threshold?(s.customObserver=new IntersectionObserver(this._handleIntersection.bind(this),{root:null,rootMargin:t.defaults.rootMargin,threshold:s.threshold}),s.customObserver.observe(e)):this.observer.observe(e);const o=s.cleanup;return s.cleanup=()=>{s.customObserver?(s.customObserver.unobserve(e),s.customObserver.disconnect()):this.observer.unobserve(e),this.revealQueue=this.revealQueue.filter(t=>t.element!==e),o()},this.eventBus?.emit("scrollreveal:mount",{element:e,threshold:s.threshold,stagger:s.stagger,timestamp:performance.now()}),this.logger?.info("Scrollreveal initialized",{element:e,threshold:s.threshold,once:s.once,stagger:s.stagger}),s}_setInitialState(e,t){if("hidden"===t.initialState){if(!e.dataset.scrollrevealClass){e.style.opacity="0";const t=e.dataset.transitionY||"1rem";e.style.transform=`translateY(${t})`}this.setAttr(e,"state","hidden")}}_handleIntersection(e){e.forEach(e=>{const t=e.target,s=this.getState(t);s&&(!e.isIntersecting||s.hasBeenRevealed||s.isRevealing?e.isIntersecting||s.once||!s.hasBeenRevealed||this._hideElement(t,s):s.stagger>0?this._addToRevealQueue(t,s):this._revealElement(t,s))})}_addToRevealQueue(e,t){this.revealQueue.push({element:e,state:t,timestamp:performance.now()}),this._processRevealQueue()}_processRevealQueue(){this.isProcessingQueue||0===this.revealQueue.length||(this.isProcessingQueue=!0,requestAnimationFrame(()=>{this._processNextInQueue()}))}_processNextInQueue(){if(0===this.revealQueue.length)return void(this.isProcessingQueue=!1);const{element:e,state:t}=this.revealQueue.shift();t.isRevealing||t.hasBeenRevealed?this._scheduleNextQueueItem(0):(this._revealElement(e,t,!0).catch(t=>{this.logger?.error("Queue reveal failed",{element:e,error:t})}),this._scheduleNextQueueItem(t.stagger))}_scheduleNextQueueItem(e=0){e>0?setTimeout(()=>{this._processNextInQueue()},e):requestAnimationFrame(()=>{this._processNextInQueue()})}async _revealElement(e,t,s=!0){t.isRevealing=!0,this.eventBus?.emit("scrollreveal:reveal-start",{element:e,timestamp:performance.now()});try{s&&t.delay>0&&await this._delay(t.delay),await this._revealItems([e],e),t.hasBeenRevealed=!0,t.once&&(t.customObserver?t.customObserver.unobserve(e):this.observer.unobserve(e)),this.eventBus?.emit("scrollreveal:reveal-complete",{element:e,timestamp:performance.now()}),this.logger?.debug("Scrollreveal animation completed",{element:e})}catch(t){this.logger?.error("Scrollreveal animation failed",{element:e,error:t}),this.eventBus?.emit("scrollreveal:reveal-error",{element:e,error:t,timestamp:performance.now()})}finally{t.isRevealing=!1}}async _hideElement(e,t){if(!t.once)try{await this._hideItems([e],e),t.hasBeenRevealed=!1,this.eventBus?.emit("scrollreveal:hide-complete",{element:e,timestamp:performance.now()})}catch(t){this.logger?.error("Scrollreveal hide animation failed",{element:e,error:t})}}async _revealItems(e,t){const s=e.map(async e=>{this.setAttr(e,"state","revealing");try{const t=e.dataset.scrollrevealClass;t?await this._animateWithClass(e,t):this.transitionManager?await this.transitionManager.enter(e):(e.style.transition="opacity 0.6s ease, transform 0.6s ease",e.style.opacity="1",e.style.transform="translateY(0)"),this.setAttr(e,"state","visible")}catch(t){throw this.setAttr(e,"state","error"),t}});await Promise.all(s)}async _hideItems(e,t){const s=e.map(async e=>{this.setAttr(e,"state","hiding");try{const t=e.dataset.scrollrevealClass,s=e.dataset.scrollrevealExitClass;if(s)await this._animateWithClass(e,s);else if(t){const s=t.split(" ").filter(e=>e.trim());e.classList.remove(...s)}else if(this.transitionManager)await this.transitionManager.exit(e);else{const t=e.dataset.transitionY||"1rem";e.style.opacity="0",e.style.transform=`translateY(${t})`}this.setAttr(e,"state","hidden")}catch(t){throw this.setAttr(e,"state","error"),t}});await Promise.all(s)}_animateWithClass(e,t){return new Promise(s=>{const r=()=>{e.removeEventListener("animationend",r),e.removeEventListener("transitionend",r),s()};e.addEventListener("animationend",r,{once:!0}),e.addEventListener("transitionend",r,{once:!0});const a=t.split(" ").filter(e=>e.trim());e.classList.add(...a),setTimeout(()=>{e.removeEventListener("animationend",r),e.removeEventListener("transitionend",r),s()},2e3)})}_delay(e){return new Promise(t=>setTimeout(t,e))}setStagger(e){this.staggerDelay=e}clearQueue(){this.revealQueue=[],this.isProcessingQueue=!1}async reveal(e){const t=this.getState(e);!t||t.hasBeenRevealed||t.isRevealing||await this._revealElement(e,t)}async hide(e){const t=this.getState(e);t&&t.hasBeenRevealed&&await this._hideElement(e,t)}reset(e){const t=this.getState(e);t&&(t.hasBeenRevealed=!1,t.isRevealing=!1,this._setInitialState(e,t),t.once&&(t.customObserver?t.customObserver.observe(e):this.observer.observe(e)),this.logger?.debug("Scrollreveal reset",{element:e}))}isRevealed(e){const t=this.getState(e);return!!t&&t.hasBeenRevealed}updateThreshold(e,s){const r=this.getState(e);r&&(r.threshold=s,r.customObserver&&r.customObserver.disconnect(),r.customObserver=new IntersectionObserver(this._handleIntersection.bind(this),{root:null,rootMargin:t.defaults.rootMargin,threshold:s}),r.customObserver.observe(e),this.logger?.info("Scrollreveal threshold updated",{element:e,threshold:s}))}getStatus(){const e=document.querySelectorAll('[data-scrollreveal-enhanced="true"]');let s=0,r=0;return e.forEach(e=>{const t=this.getState(e);t&&(t.hasBeenRevealed&&s++,t.isRevealing&&r++)}),{totalElements:e.length,revealedCount:s,revealingCount:r,queuedCount:this.revealQueue.length,observerActive:!!this.observer,defaults:t.defaults}}destroy(){this.observer&&(this.observer.disconnect(),this.observer=null),this.revealQueue=[],this.isProcessingQueue=!1,super.destroy(),this.logger?.info("Scrollreveal destroyed")}static enhanceAll(e="[data-scrollreveal]",s){const r=new t(s);return document.querySelectorAll(e).forEach(e=>{r.mount(e)}),r}}export{t as default};
