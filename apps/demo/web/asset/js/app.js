(()=>{"use strict";var __webpack_modules__={35:()=>{eval('{\n;// ../../packages/core/dist/index.js\n// src/EventBus.js\nvar EventBus = class {\n  constructor() {\n    this.listeners = /* @__PURE__ */ new Map();\n  }\n  on(evt, fn) {\n    (this.listeners.get(evt) ?? this.listeners.set(evt, /* @__PURE__ */ new Set()).get(evt)).add(fn);\n    return () => this.off(evt, fn);\n  }\n  once(evt, fn) {\n    const off = this.on(evt, (p) => {\n      off();\n      fn(p);\n    });\n    return off;\n  }\n  off(evt, fn) {\n    const set = this.listeners.get(evt);\n    if (set) {\n      set.delete(fn);\n      if (!set.size) this.listeners.delete(evt);\n    }\n  }\n  emit(evt, payload) {\n    const set = this.listeners.get(evt);\n    if (!set) return;\n    for (const fn of [...set]) {\n      try {\n        fn(payload);\n      } catch (e) {\n        console.error(`[event:${evt}] handler error`, e);\n      }\n    }\n  }\n};\n\n// src/DevLogger.js\nvar DevLogger = class {\n  constructor(ns, enabled = false) {\n    this.ns = ns;\n    this.enabled = enabled;\n  }\n  setEnabled(v) {\n    this.enabled = !!v;\n  }\n  _pfx(level) {\n    return `${(/* @__PURE__ */ new Date()).toISOString()} [${this.ns}] ${level}:`;\n  }\n  log(...a) {\n    if (this.enabled) console.log(this._pfx("log"), ...a);\n  }\n  info(...a) {\n    if (this.enabled) console.info(this._pfx("info"), ...a);\n  }\n  warn(...a) {\n    if (this.enabled) console.warn(this._pfx("warn"), ...a);\n  }\n  error(...a) {\n    console.error(this._pfx("error"), ...a);\n  }\n  group(label) {\n    if (this.enabled && console.groupCollapsed) console.groupCollapsed(`[${this.ns}] ${label}`);\n  }\n  groupEnd() {\n    if (this.enabled && console.groupEnd) console.groupEnd();\n  }\n  time(label) {\n    if (this.enabled && console.time) console.time(`[${this.ns}] ${label}`);\n  }\n  timeEnd(label) {\n    if (this.enabled && console.timeEnd) console.timeEnd(`[${this.ns}] ${label}`);\n  }\n};\n\n// src/idle.js\nfunction createIdle() {\n  const ric = typeof window !== "undefined" && window.requestIdleCallback ? window.requestIdleCallback : (cb, { timeout } = {}) => setTimeout(() => cb({ didTimeout: false, timeRemaining: () => Math.max(0, 50) }), timeout ?? 1);\n  const cic = typeof window !== "undefined" && window.cancelIdleCallback ? window.cancelIdleCallback : (id) => clearTimeout(id);\n  const schedule = (fn, timeout = 1200) => ric(fn, { timeout });\n  schedule.cancel = cic;\n  return schedule;\n}\nfunction cancelIdle(id) {\n  const cic = typeof window !== "undefined" && window.cancelIdleCallback ? window.cancelIdleCallback : (id2) => clearTimeout(id2);\n  cic(id);\n}\n\n\n//# sourceMappingURL=index.js.map\n//# sourceMappingURL=index.js.map\n;// ../../packages/page/dist/index.js\n\n\n// src/BaseComponent.js\nvar BaseComponent = class {\n  constructor({ eventBus, logger, router }) {\n    this.eventBus = eventBus;\n    this.logger = logger;\n    this.router = router;\n    this.elements = /* @__PURE__ */ new WeakMap();\n  }\n  mount(el) {\n    if (this.elements.has(el)) return this.update(el);\n    const state = this._init(el);\n    this.elements.set(el, state);\n  }\n  update(el) {\n  }\n  unmount(el) {\n    var _a;\n    const state = this.elements.get(el);\n    if (!state) return;\n    try {\n      (_a = state.cleanup) == null ? void 0 : _a.call(state);\n    } finally {\n      this.elements.delete(el);\n    }\n  }\n  destroy() {\n    for (const el of this._elementsKeys()) this.unmount(el);\n  }\n  _elementsKeys() {\n    if (!this._keys) this._keys = /* @__PURE__ */ new Set();\n    return this._keys;\n  }\n  _track(el) {\n    if (!this._keys) this._keys = /* @__PURE__ */ new Set();\n    this._keys.add(el);\n  }\n  _untrack(el) {\n    var _a;\n    (_a = this._keys) == null ? void 0 : _a.delete(el);\n  }\n  _init(el) {\n    const controller = new AbortController();\n    const cleanup = () => {\n      controller.abort();\n      this._untrack(el);\n    };\n    this._track(el);\n    return { cleanup, controller };\n  }\n};\nvar QueuedComponentProxy = class extends BaseComponent {\n  constructor(onMount, onUnmount) {\n    super({ eventBus: { on() {\n    }, emit() {\n    } }, logger: { info() {\n    }, error() {\n    }, enabled: false }, router: null });\n    this._onMount = onMount;\n    this._onUnmount = onUnmount;\n  }\n  mount(el) {\n    this._onMount(el);\n  }\n  unmount(el) {\n    this._onUnmount(el);\n  }\n};\nvar idle = createIdle();\nvar PageManager = class {\n  constructor({ containerSelector, registry, eventBus, logger, router }) {\n    this.eventBus = eventBus;\n    this.logger = logger;\n    this.router = router;\n    this.containerSelector = containerSelector;\n    this.registry = registry;\n    this.instances = /* @__PURE__ */ new Map();\n    this.observer = null;\n    this.eventBus.on("route:success", ({ html }) => this.replaceFragment(html));\n    this.eventBus.on("route:pop", async ({ url }) => {\n      var _a, _b;\n      try {\n        const { data } = await this.router.get(url.toString());\n        if (typeof data === "string") this.replaceFragment(data, { fromPop: true });\n      } catch (e) {\n        (_b = (_a = this.logger).error) == null ? void 0 : _b.call(_a, "route:pop fetch failed", e);\n      }\n    });\n  }\n  get container() {\n    const el = document.querySelector(this.containerSelector);\n    if (!el) throw new Error(`Container not found: ${this.containerSelector}`);\n    return el;\n  }\n  replaceFragment(html, { fromPop = false } = {}) {\n    const root = this.container;\n    this.eventBus.emit("fragment:will-unmount", { root });\n    this.unmountAllWithin(root);\n    const tpl = document.createElement("template");\n    tpl.innerHTML = html.trim();\n    root.replaceChildren(...tpl.content.childNodes);\n    this.eventBus.emit("fragment:did-mount", { root });\n    this.mountAllWithin(root);\n    idle(() => this.mountAllWithin(root), 1200);\n    if (!this.observer) this._startObserver(root);\n  }\n  _startObserver(root) {\n    if (!("MutationObserver" in window)) return;\n    this.observer = new MutationObserver((mutations) => {\n      let added = [], removed = [];\n      for (const m of mutations) {\n        if (m.addedNodes) added = added.concat([...m.addedNodes].filter((n) => n.nodeType === 1));\n        if (m.removedNodes) removed = removed.concat([...m.removedNodes].filter((n) => n.nodeType === 1));\n      }\n      if (added.length) {\n        this.mountAllWithin(root, added);\n      }\n      if (removed.length) {\n        this.unmountRemoved(removed);\n      }\n    });\n    this.observer.observe(root, { childList: true, subtree: true });\n  }\n  mountAllWithin(root, addedNodes = null) {\n    var _a, _b, _c, _d;\n    (_b = (_a = this.logger).group) == null ? void 0 : _b.call(_a, "mountAllWithin");\n    try {\n      for (const cfg of this.registry) {\n        const scope = addedNodes ? addedNodes : [root];\n        const els = scope.flatMap((node) => [...node.querySelectorAll(cfg.selector)]);\n        if (!els.length) continue;\n        const instance = this._ensureInstance(cfg);\n        for (const el of els) instance.mount(el);\n      }\n    } finally {\n      (_d = (_c = this.logger).groupEnd) == null ? void 0 : _d.call(_c);\n    }\n  }\n  unmountAllWithin(root) {\n    var _a, _b, _c, _d, _e;\n    (_b = (_a = this.logger).group) == null ? void 0 : _b.call(_a, "unmountAllWithin");\n    try {\n      for (const inst of this.instances.values()) {\n        for (const el of ((_c = inst._elementsKeys) == null ? void 0 : _c.call(inst)) || []) {\n          if (root.contains(el)) inst.unmount(el);\n        }\n      }\n    } finally {\n      (_e = (_d = this.logger).groupEnd) == null ? void 0 : _e.call(_d);\n    }\n  }\n  unmountRemoved(nodes) {\n    var _a;\n    for (const inst of this.instances.values()) {\n      for (const el of ((_a = inst._elementsKeys) == null ? void 0 : _a.call(inst)) || []) {\n        if (!document.documentElement.contains(el)) inst.unmount(el);\n      }\n    }\n  }\n  _ensureInstance(cfg) {\n    var _a;\n    let inst = this.instances.get(cfg.name);\n    if (inst) return inst;\n    if ((_a = cfg.dependsOn) == null ? void 0 : _a.length) {\n      for (const dep of cfg.dependsOn) {\n        const depCfg = this.registry.find((c) => c.name === dep);\n        if (depCfg) this._ensureInstance(depCfg);\n      }\n    }\n    const ctorPromiseLike = cfg.loader();\n    const ctorMaybe = ctorPromiseLike instanceof Promise ? null : ctorPromiseLike;\n    const create = (Ctor) => {\n      const i = new Ctor({ eventBus: this.eventBus, logger: this.logger, router: this.router });\n      this.instances.set(cfg.name, i);\n      return i;\n    };\n    if (ctorMaybe) return create(ctorMaybe.default);\n    const queue = [];\n    const placeholder = new QueuedComponentProxy((el) => queue.push(["mount", el]), (el) => queue.push(["unmount", el]));\n    this.instances.set(cfg.name, placeholder);\n    cfg.loader().then((mod) => {\n      var _a2, _b;\n      const real = create(mod.default);\n      for (const [action, el] of queue) {\n        try {\n          real[action](el);\n        } catch (e) {\n          (_b = (_a2 = this.logger).error) == null ? void 0 : _b.call(_a2, `dequeued ${cfg.name}.${action} failed`, e);\n        }\n      }\n      this.instances.set(cfg.name, real);\n    }).catch((e) => {\n      var _a2, _b;\n      return (_b = (_a2 = this.logger).error) == null ? void 0 : _b.call(_a2, `Failed to load component ${cfg.name}`, e);\n    });\n    return placeholder;\n  }\n};\n\n\n//# sourceMappingURL=index.js.map\n//# sourceMappingURL=index.js.map\n;// ../../packages/components/dist/index.js\n// src/XModal.js\nvar XModal = class extends HTMLElement {\n  static get observedAttributes() {\n    return ["open"];\n  }\n  constructor() {\n    super();\n    const root = this.attachShadow({ mode: "open" });\n    root.innerHTML = `\n      <style>\n        :host{ display:none; }\n        :host([open]){ display:block; position:fixed; inset:0; z-index:9999; }\n        .backdrop{ position:absolute; inset:0; background:rgba(0,0,0,.45); }\n        .panel{ position:absolute; inset:auto; top:50%; left:50%; transform:translate(-50%,-50%);\n                min-width: min(92vw, 640px); max-width: 92vw; max-height: 86vh; overflow:auto;\n                background:#0f172a; color:#e5e7eb; border:1px solid rgba(255,255,255,.08); border-radius:16px; box-shadow:0 20px 60px rgba(0,0,0,.5); }\n        header{ display:flex; align-items:center; gap:8px; padding:12px 14px; border-bottom:1px solid rgba(255,255,255,.08); position:sticky; top:0; background:#0f172a; }\n        header h2{ margin:0; font-size:18px; line-height:1.3; }\n        .spacer{ flex:1; }\n        button.icon{ all:unset; display:inline-flex; align-items:center; justify-content:center; width:28px; height:28px; border-radius:8px; cursor:pointer; }\n        section{ padding:14px; }\n        footer{ padding:12px 14px; border-top:1px solid rgba(255,255,255,.08); display:flex; gap:8px; justify-content:flex-end; position:sticky; bottom:0; background:#0f172a; }\n        ::slotted(.btn){ appearance:none; border:0; border-radius:10px; padding:10px 14px; background:#1f2937; color:#fff; cursor:pointer; }\n        ::slotted(.btn.accent){ background:#60a5fa; color:#0b1020; font-weight:700; }\n      </style>\n      <div class="backdrop" part="backdrop"></div>\n      <div class="panel" part="panel" role="dialog" aria-modal="true">\n        <header part="header">\n          <slot name="title"><h2>Dialog</h2></slot>\n          <div class="spacer"></div>\n          <button class="icon" aria-label="Close" part="close">\\xD7</button>\n        </header>\n        <section part="content"><slot></slot></section>\n        <footer part="footer"><slot name="actions"></slot></footer>\n      </div>\n    `;\n    this._els = {\n      backdrop: root.querySelector(".backdrop"),\n      panel: root.querySelector(".panel"),\n      close: root.querySelector("button.icon")\n    };\n    this._onKeydown = this._onKeydown.bind(this);\n    this._onFocus = this._onFocus.bind(this);\n  }\n  connectedCallback() {\n    this._upgradeProperty("open");\n    this._els.backdrop.addEventListener("click", () => this._closable() && this.close());\n    this._els.close.addEventListener("click", () => this._closable() && this.close());\n    document.addEventListener("keydown", this._onKeydown);\n    this.addEventListener("focusin", this._onFocus);\n  }\n  disconnectedCallback() {\n    document.removeEventListener("keydown", this._onKeydown);\n    this.removeEventListener("focusin", this._onFocus);\n  }\n  attributeChangedCallback(name) {\n    if (name === "open") {\n      if (this.hasAttribute("open")) {\n        this.dispatchEvent(new CustomEvent("open", { bubbles: true }));\n        const f = this._firstFocusable();\n        (f || this._els.close).focus({ preventScroll: true });\n      } else {\n        this.dispatchEvent(new CustomEvent("close", { bubbles: true }));\n      }\n    }\n  }\n  open() {\n    this.setAttribute("open", "");\n  }\n  close() {\n    this.removeAttribute("open");\n  }\n  toggle(force) {\n    if (force === true) this.open();\n    else if (force === false) this.close();\n    else this.hasAttribute("open") ? this.close() : this.open();\n  }\n  _closable() {\n    return this.getAttribute("closable") !== "false";\n  }\n  _upgradeProperty(prop) {\n    if (this.hasOwnProperty(prop)) {\n      let v = this[prop];\n      delete this[prop];\n      this[prop] = v;\n    }\n  }\n  _onKeydown(e) {\n    if (!this.hasAttribute("open")) return;\n    if (e.key === "Escape" && this._closable()) {\n      this.close();\n    }\n    if (e.key === "Tab") {\n      this._trapTab(e);\n    }\n  }\n  _onFocus() {\n    if (!this.contains(document.activeElement)) {\n      (this._firstFocusable() || this._els.close).focus({ preventScroll: true });\n    }\n  }\n  _focusables() {\n    const sel = ["a[href]", "button", "input", "select", "textarea", \'[tabindex]:not([tabindex="-1"])\'].join(",");\n    return [...this.querySelectorAll(sel)].filter((el) => !el.hasAttribute("disabled"));\n  }\n  _firstFocusable() {\n    return this._focusables()[0];\n  }\n  _trapTab(e) {\n    const f = this._focusables();\n    if (!f.length) return;\n    const first = f[0], last = f[f.length - 1];\n    const active = this.contains(document.activeElement) ? document.activeElement : null;\n    if (e.shiftKey) {\n      if (active === first || !active) {\n        last.focus();\n        e.preventDefault();\n      }\n    } else {\n      if (active === last) {\n        first.focus();\n        e.preventDefault();\n      }\n    }\n  }\n};\nif (!customElements.get("x-modal")) customElements.define("x-modal", XModal);\n\n\n//# sourceMappingURL=index.js.map\n//# sourceMappingURL=index.js.map\n;// ../../packages/ui/dist/index.js\n// src/XToasts.js\nvar XToasts = class extends HTMLElement {\n  constructor() {\n    super();\n    const root = this.attachShadow({ mode: "open" });\n    root.innerHTML = `\n      <style>\n        :host{position:fixed; inset:auto auto auto 0; padding:12px; z-index:2147483647; display:grid; gap:8px;}\n        :host([placement="top-left"]){ top:0; left:0; }\n        :host([placement="top-right"]){ top:0; right:0; left:auto; }\n        :host([placement="bottom-right"]){ bottom:0; right:0; left:auto; }\n        :host([placement="bottom-left"]){ bottom:0; left:0; }\n        .toast{ padding:10px 12px; border-radius:8px; color:#fff; box-shadow:0 6px 20px rgba(0,0,0,.25); opacity:0; transform: translateY(-6px);\n                animation: in .18s ease-out forwards; cursor:pointer; font: 14px/1.4 system-ui, -apple-system, Segoe UI, Roboto, sans-serif; outline:none;}\n        .toast.info{ background:#111827; }\n        .toast.success{ background:#065f46; }\n        .toast.warn{ background:#7c2d12; }\n        .toast.error{ background:#7f1d1d; }\n        .toast.loading{ background:#0f172a; }\n        @keyframes in{ to{ opacity:1; transform:none; } }\n        @keyframes out{ to{ opacity:0; transform: translateY(-6px); } }\n        .row{ display:flex; align-items:center; gap:8px; }\n        .msg{ white-space:pre-wrap; }\n        button.icon{ all:unset; display:inline-flex; align-items:center; justify-content:center; width:24px; height:24px; border-radius:6px; font-weight:700; }\n        button.action{ all:unset; padding:4px 8px; border-radius:6px; background:rgba(255,255,255,.15); font-weight:600; }\n        .spacer{ flex:1; }\n        .bar{ position:relative; height:6px; border-radius:999px; overflow:hidden; background: rgba(255,255,255,.18); margin-top:8px; }\n        .bar > .fill{ position:absolute; inset:0 auto 0 0; width:0%; background: rgba(255,255,255,.85); border-radius:inherit; }\n        .bar.indeterminate > .fill{ width:40%; animation: indet 1.2s ease-in-out infinite; }\n        @keyframes indet { 0%{ left:-40%; } 50%{ left:60%; } 100%{ left:100%; } }\n        .spin{ width:16px; height:16px; border-radius:50%; border:2px solid rgba(255,255,255,.35); border-top-color:#fff; animation: spin .8s linear infinite; }\n        @keyframes spin{ to{ transform: rotate(360deg); } }\n      </style>\n      <div id="wrap" role="region" aria-live="polite"></div>`;\n    this._wrap = root.getElementById("wrap");\n    this._id = 0;\n  }\n  toast({ message, type = "info", timeout = 4e3, allowHTML = false, action }) {\n    const id = ++this._id;\n    const el = document.createElement("div");\n    el.className = `toast ${type}`;\n    const role = type === "warn" || type === "error" ? "alert" : "status";\n    el.setAttribute("role", role);\n    el.tabIndex = 0;\n    const row = document.createElement("div");\n    row.className = "row";\n    const span = document.createElement("span");\n    span.className = "msg";\n    if (allowHTML) span.innerHTML = message;\n    else span.textContent = message;\n    const spacer = document.createElement("div");\n    spacer.className = "spacer";\n    let actionBtn = null;\n    if (action == null ? void 0 : action.label) {\n      actionBtn = document.createElement("button");\n      actionBtn.className = "action";\n      actionBtn.type = "button";\n      actionBtn.textContent = action.label;\n      actionBtn.addEventListener("click", (ev) => {\n        var _a;\n        this.dispatchEvent(new CustomEvent("toast:action", { detail: { id, type, message }, bubbles: true }));\n        (_a = action.onClick) == null ? void 0 : _a.call(action, ev);\n        remove();\n      });\n    }\n    const close = document.createElement("button");\n    close.className = "icon";\n    close.setAttribute("aria-label", "Dismiss notification");\n    close.textContent = "\\xD7";\n    row.append(span, spacer);\n    if (actionBtn) row.append(actionBtn);\n    row.append(close);\n    el.append(row);\n    this._wrap.append(el);\n    const removeNow = () => {\n      el.style.animation = "out .15s ease-in forwards";\n      setTimeout(() => el.remove(), 150);\n    };\n    let removed = false;\n    const remove = () => {\n      if (removed) return;\n      removed = true;\n      removeNow();\n      this.dispatchEvent(new CustomEvent("toast:close", { detail: { id, type, message }, bubbles: true }));\n    };\n    const tid = timeout ? setTimeout(remove, timeout) : null;\n    const cancelTimer = () => tid && clearTimeout(tid);\n    close.addEventListener("click", remove);\n    el.addEventListener("mouseenter", cancelTimer);\n    el.addEventListener("focusin", cancelTimer);\n    el.addEventListener("mouseleave", () => {\n      if (timeout && !removed) setTimeout(remove, 1e3);\n    });\n    this.dispatchEvent(new CustomEvent("toast:show", { detail: { id, type, message }, bubbles: true }));\n    return remove;\n  }\n  progress({ message, determinate = false, value = 0, max = 100, cancellable = false, onCancel }) {\n    const id = ++this._id;\n    const el = document.createElement("div");\n    el.className = "toast loading";\n    el.setAttribute("role", "status");\n    el.tabIndex = 0;\n    const row = document.createElement("div");\n    row.className = "row";\n    const spin = document.createElement("div");\n    spin.className = "spin";\n    row.append(spin);\n    const span = document.createElement("span");\n    span.className = "msg";\n    span.textContent = message;\n    row.append(span);\n    const spacer = document.createElement("div");\n    spacer.className = "spacer";\n    row.append(spacer);\n    const close = document.createElement("button");\n    close.className = "icon";\n    close.setAttribute("aria-label", cancellable ? "Cancel" : "Dismiss");\n    close.textContent = "\\u2A2F";\n    row.append(close);\n    el.append(row);\n    const bar = document.createElement("div");\n    bar.className = "bar" + (determinate ? "" : " indeterminate");\n    const fill = document.createElement("div");\n    fill.className = "fill";\n    bar.append(fill);\n    el.append(bar);\n    this._wrap.append(el);\n    const set = (n) => {\n      if (!determinate) return;\n      const pct = Math.max(0, Math.min(100, n / max * 100));\n      fill.style.width = pct + "%";\n    };\n    if (determinate) set(value);\n    const dismiss = () => el.remove();\n    const succeed = (m) => {\n      if (m) span.textContent = m;\n      el.classList.add("success");\n      setTimeout(dismiss, 1200);\n    };\n    const fail = (m) => {\n      if (m) span.textContent = m;\n      el.classList.add("error");\n      setTimeout(dismiss, 1600);\n    };\n    close.addEventListener("click", () => {\n      if (cancellable && onCancel) onCancel();\n      dismiss();\n    });\n    this.dispatchEvent(new CustomEvent("toast:show", { detail: { id, type: "loading", message }, bubbles: true }));\n    return { id, set, setMessage: (m) => span.textContent = m, succeed, fail, dismiss };\n  }\n};\nif (!customElements.get("x-toasts")) customElements.define("x-toasts", XToasts);\n\n// src/AlertManager.js\nvar AlertManager = class {\n  constructor({ logger, eventBus, placement = "top-right" }) {\n    this.logger = logger;\n    this.eventBus = eventBus;\n    this.el = document.querySelector("x-toasts") || document.body.appendChild(document.createElement("x-toasts"));\n    this.el.setAttribute("placement", placement);\n    this.el.addEventListener("toast:show", (e) => {\n      var _a, _b;\n      const d = e.detail;\n      (_b = (_a = this.logger).info) == null ? void 0 : _b.call(_a, "toast:show", d);\n      this.eventBus.emit("alerts:show", d);\n    });\n    this.el.addEventListener("toast:close", (e) => {\n      var _a, _b;\n      const d = e.detail;\n      (_b = (_a = this.logger).info) == null ? void 0 : _b.call(_a, "toast:close", d);\n      this.eventBus.emit("alerts:close", d);\n    });\n    this.el.addEventListener("toast:action", (e) => {\n      var _a, _b;\n      const d = e.detail;\n      (_b = (_a = this.logger).info) == null ? void 0 : _b.call(_a, "toast:action", d);\n      this.eventBus.emit("alerts:action", d);\n    });\n  }\n  toast(opts) {\n    var _a, _b;\n    const dismiss = this.el.toast(opts);\n    (_b = (_a = this.logger).info) == null ? void 0 : _b.call(_a, "toast", opts);\n    return dismiss;\n  }\n  progress(opts) {\n    return this.el.progress(opts);\n  }\n};\n\n\n//# sourceMappingURL=index.js.map\n//# sourceMappingURL=index.js.map\n;// ./src/js/main.js\n\n\n\n\nfunction kickoffEnterTransition(app){\n  app.classList.remove(\'is-entered\');\n  requestAnimationFrame(() => app.classList.add(\'is-entered\'));\n}\n\nfunction boot(){\n  const app = document.querySelector(\'#app\');\n  if (!app) return;\n\n  // Initial mount once\n  kickoffEnterTransition(app);\n\n  // Example router / PageManager wiring\n  const pageManager = new PageManager({ container: app });\n\n  document.addEventListener(\'event:route:success\', async (e) => {\n    // out\n    app.classList.remove(\'is-entered\');\n    // small frame to allow CSS to pick up state change\n    await new Promise(r => requestAnimationFrame(r));\n\n    // render new content (assuming PageManager knows how)\n    await pageManager.render(e.detail);\n\n    // (re)mount components in the new DOM\n    safeMountAllWithin(app);\n\n    // in\n    requestAnimationFrame(() => app.classList.add(\'is-entered\'));\n  });\n}\n\ndocument.addEventListener(\'DOMContentLoaded\', boot);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsdURBQXVELFVBQVUsOEJBQThCLGlCQUFpQjtBQUNoSCxhQUFhO0FBQ2I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxnQkFBZ0IsMkNBQTJDO0FBQzNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFaUM7QUFDakM7QUFDQSxpQzs7QUNqTTZDO0FBQ2Y7QUFDUjs7QUFFdEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSwwQkFBMEIsV0FBVyxHQUFHLGdCQUFnQjs7QUFFeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQSIsInNvdXJjZXMiOlsid2VicGFjazovLy8uLi8uLi9wYWNrYWdlcy9jb3JlL2Rpc3QvaW5kZXguanM/OTZmNiIsIndlYnBhY2s6Ly8vLi4vLi4vcGFja2FnZXMvcGFnZS9kaXN0L2luZGV4LmpzPzM2NTIiLCJ3ZWJwYWNrOi8vLy4uLy4uL3BhY2thZ2VzL2NvbXBvbmVudHMvZGlzdC9pbmRleC5qcz82ZjFkIiwid2VicGFjazovLy8uLi8uLi9wYWNrYWdlcy91aS9kaXN0L2luZGV4LmpzPzVhZmYiLCJ3ZWJwYWNrOi8vLy4vc3JjL2pzL21haW4uanM/OTI5MSJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBzcmMvRXZlbnRCdXMuanNcbnZhciBFdmVudEJ1cyA9IGNsYXNzIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgdGhpcy5saXN0ZW5lcnMgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICB9XG4gIG9uKGV2dCwgZm4pIHtcbiAgICAodGhpcy5saXN0ZW5lcnMuZ2V0KGV2dCkgPz8gdGhpcy5saXN0ZW5lcnMuc2V0KGV2dCwgLyogQF9fUFVSRV9fICovIG5ldyBTZXQoKSkuZ2V0KGV2dCkpLmFkZChmbik7XG4gICAgcmV0dXJuICgpID0+IHRoaXMub2ZmKGV2dCwgZm4pO1xuICB9XG4gIG9uY2UoZXZ0LCBmbikge1xuICAgIGNvbnN0IG9mZiA9IHRoaXMub24oZXZ0LCAocCkgPT4ge1xuICAgICAgb2ZmKCk7XG4gICAgICBmbihwKTtcbiAgICB9KTtcbiAgICByZXR1cm4gb2ZmO1xuICB9XG4gIG9mZihldnQsIGZuKSB7XG4gICAgY29uc3Qgc2V0ID0gdGhpcy5saXN0ZW5lcnMuZ2V0KGV2dCk7XG4gICAgaWYgKHNldCkge1xuICAgICAgc2V0LmRlbGV0ZShmbik7XG4gICAgICBpZiAoIXNldC5zaXplKSB0aGlzLmxpc3RlbmVycy5kZWxldGUoZXZ0KTtcbiAgICB9XG4gIH1cbiAgZW1pdChldnQsIHBheWxvYWQpIHtcbiAgICBjb25zdCBzZXQgPSB0aGlzLmxpc3RlbmVycy5nZXQoZXZ0KTtcbiAgICBpZiAoIXNldCkgcmV0dXJuO1xuICAgIGZvciAoY29uc3QgZm4gb2YgWy4uLnNldF0pIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGZuKHBheWxvYWQpO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBjb25zb2xlLmVycm9yKGBbZXZlbnQ6JHtldnR9XSBoYW5kbGVyIGVycm9yYCwgZSk7XG4gICAgICB9XG4gICAgfVxuICB9XG59O1xuXG4vLyBzcmMvRGV2TG9nZ2VyLmpzXG52YXIgRGV2TG9nZ2VyID0gY2xhc3Mge1xuICBjb25zdHJ1Y3RvcihucywgZW5hYmxlZCA9IGZhbHNlKSB7XG4gICAgdGhpcy5ucyA9IG5zO1xuICAgIHRoaXMuZW5hYmxlZCA9IGVuYWJsZWQ7XG4gIH1cbiAgc2V0RW5hYmxlZCh2KSB7XG4gICAgdGhpcy5lbmFibGVkID0gISF2O1xuICB9XG4gIF9wZngobGV2ZWwpIHtcbiAgICByZXR1cm4gYCR7KC8qIEBfX1BVUkVfXyAqLyBuZXcgRGF0ZSgpKS50b0lTT1N0cmluZygpfSBbJHt0aGlzLm5zfV0gJHtsZXZlbH06YDtcbiAgfVxuICBsb2coLi4uYSkge1xuICAgIGlmICh0aGlzLmVuYWJsZWQpIGNvbnNvbGUubG9nKHRoaXMuX3BmeChcImxvZ1wiKSwgLi4uYSk7XG4gIH1cbiAgaW5mbyguLi5hKSB7XG4gICAgaWYgKHRoaXMuZW5hYmxlZCkgY29uc29sZS5pbmZvKHRoaXMuX3BmeChcImluZm9cIiksIC4uLmEpO1xuICB9XG4gIHdhcm4oLi4uYSkge1xuICAgIGlmICh0aGlzLmVuYWJsZWQpIGNvbnNvbGUud2Fybih0aGlzLl9wZngoXCJ3YXJuXCIpLCAuLi5hKTtcbiAgfVxuICBlcnJvciguLi5hKSB7XG4gICAgY29uc29sZS5lcnJvcih0aGlzLl9wZngoXCJlcnJvclwiKSwgLi4uYSk7XG4gIH1cbiAgZ3JvdXAobGFiZWwpIHtcbiAgICBpZiAodGhpcy5lbmFibGVkICYmIGNvbnNvbGUuZ3JvdXBDb2xsYXBzZWQpIGNvbnNvbGUuZ3JvdXBDb2xsYXBzZWQoYFske3RoaXMubnN9XSAke2xhYmVsfWApO1xuICB9XG4gIGdyb3VwRW5kKCkge1xuICAgIGlmICh0aGlzLmVuYWJsZWQgJiYgY29uc29sZS5ncm91cEVuZCkgY29uc29sZS5ncm91cEVuZCgpO1xuICB9XG4gIHRpbWUobGFiZWwpIHtcbiAgICBpZiAodGhpcy5lbmFibGVkICYmIGNvbnNvbGUudGltZSkgY29uc29sZS50aW1lKGBbJHt0aGlzLm5zfV0gJHtsYWJlbH1gKTtcbiAgfVxuICB0aW1lRW5kKGxhYmVsKSB7XG4gICAgaWYgKHRoaXMuZW5hYmxlZCAmJiBjb25zb2xlLnRpbWVFbmQpIGNvbnNvbGUudGltZUVuZChgWyR7dGhpcy5uc31dICR7bGFiZWx9YCk7XG4gIH1cbn07XG5cbi8vIHNyYy9pZGxlLmpzXG5mdW5jdGlvbiBjcmVhdGVJZGxlKCkge1xuICBjb25zdCByaWMgPSB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiICYmIHdpbmRvdy5yZXF1ZXN0SWRsZUNhbGxiYWNrID8gd2luZG93LnJlcXVlc3RJZGxlQ2FsbGJhY2sgOiAoY2IsIHsgdGltZW91dCB9ID0ge30pID0+IHNldFRpbWVvdXQoKCkgPT4gY2IoeyBkaWRUaW1lb3V0OiBmYWxzZSwgdGltZVJlbWFpbmluZzogKCkgPT4gTWF0aC5tYXgoMCwgNTApIH0pLCB0aW1lb3V0ID8/IDEpO1xuICBjb25zdCBjaWMgPSB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiICYmIHdpbmRvdy5jYW5jZWxJZGxlQ2FsbGJhY2sgPyB3aW5kb3cuY2FuY2VsSWRsZUNhbGxiYWNrIDogKGlkKSA9PiBjbGVhclRpbWVvdXQoaWQpO1xuICBjb25zdCBzY2hlZHVsZSA9IChmbiwgdGltZW91dCA9IDEyMDApID0+IHJpYyhmbiwgeyB0aW1lb3V0IH0pO1xuICBzY2hlZHVsZS5jYW5jZWwgPSBjaWM7XG4gIHJldHVybiBzY2hlZHVsZTtcbn1cbmZ1bmN0aW9uIGNhbmNlbElkbGUoaWQpIHtcbiAgY29uc3QgY2ljID0gdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiAmJiB3aW5kb3cuY2FuY2VsSWRsZUNhbGxiYWNrID8gd2luZG93LmNhbmNlbElkbGVDYWxsYmFjayA6IChpZDIpID0+IGNsZWFyVGltZW91dChpZDIpO1xuICBjaWMoaWQpO1xufVxuXG5leHBvcnQgeyBEZXZMb2dnZXIsIEV2ZW50QnVzLCBjYW5jZWxJZGxlLCBjcmVhdGVJZGxlIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXBcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCIsImltcG9ydCB7IGNyZWF0ZUlkbGUgfSBmcm9tICdAY29udGVuaXIvY29yZSc7XG5cbi8vIHNyYy9CYXNlQ29tcG9uZW50LmpzXG52YXIgQmFzZUNvbXBvbmVudCA9IGNsYXNzIHtcbiAgY29uc3RydWN0b3IoeyBldmVudEJ1cywgbG9nZ2VyLCByb3V0ZXIgfSkge1xuICAgIHRoaXMuZXZlbnRCdXMgPSBldmVudEJ1cztcbiAgICB0aGlzLmxvZ2dlciA9IGxvZ2dlcjtcbiAgICB0aGlzLnJvdXRlciA9IHJvdXRlcjtcbiAgICB0aGlzLmVsZW1lbnRzID0gLyogQF9fUFVSRV9fICovIG5ldyBXZWFrTWFwKCk7XG4gIH1cbiAgbW91bnQoZWwpIHtcbiAgICBpZiAodGhpcy5lbGVtZW50cy5oYXMoZWwpKSByZXR1cm4gdGhpcy51cGRhdGUoZWwpO1xuICAgIGNvbnN0IHN0YXRlID0gdGhpcy5faW5pdChlbCk7XG4gICAgdGhpcy5lbGVtZW50cy5zZXQoZWwsIHN0YXRlKTtcbiAgfVxuICB1cGRhdGUoZWwpIHtcbiAgfVxuICB1bm1vdW50KGVsKSB7XG4gICAgdmFyIF9hO1xuICAgIGNvbnN0IHN0YXRlID0gdGhpcy5lbGVtZW50cy5nZXQoZWwpO1xuICAgIGlmICghc3RhdGUpIHJldHVybjtcbiAgICB0cnkge1xuICAgICAgKF9hID0gc3RhdGUuY2xlYW51cCkgPT0gbnVsbCA/IHZvaWQgMCA6IF9hLmNhbGwoc3RhdGUpO1xuICAgIH0gZmluYWxseSB7XG4gICAgICB0aGlzLmVsZW1lbnRzLmRlbGV0ZShlbCk7XG4gICAgfVxuICB9XG4gIGRlc3Ryb3koKSB7XG4gICAgZm9yIChjb25zdCBlbCBvZiB0aGlzLl9lbGVtZW50c0tleXMoKSkgdGhpcy51bm1vdW50KGVsKTtcbiAgfVxuICBfZWxlbWVudHNLZXlzKCkge1xuICAgIGlmICghdGhpcy5fa2V5cykgdGhpcy5fa2V5cyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KCk7XG4gICAgcmV0dXJuIHRoaXMuX2tleXM7XG4gIH1cbiAgX3RyYWNrKGVsKSB7XG4gICAgaWYgKCF0aGlzLl9rZXlzKSB0aGlzLl9rZXlzID0gLyogQF9fUFVSRV9fICovIG5ldyBTZXQoKTtcbiAgICB0aGlzLl9rZXlzLmFkZChlbCk7XG4gIH1cbiAgX3VudHJhY2soZWwpIHtcbiAgICB2YXIgX2E7XG4gICAgKF9hID0gdGhpcy5fa2V5cykgPT0gbnVsbCA/IHZvaWQgMCA6IF9hLmRlbGV0ZShlbCk7XG4gIH1cbiAgX2luaXQoZWwpIHtcbiAgICBjb25zdCBjb250cm9sbGVyID0gbmV3IEFib3J0Q29udHJvbGxlcigpO1xuICAgIGNvbnN0IGNsZWFudXAgPSAoKSA9PiB7XG4gICAgICBjb250cm9sbGVyLmFib3J0KCk7XG4gICAgICB0aGlzLl91bnRyYWNrKGVsKTtcbiAgICB9O1xuICAgIHRoaXMuX3RyYWNrKGVsKTtcbiAgICByZXR1cm4geyBjbGVhbnVwLCBjb250cm9sbGVyIH07XG4gIH1cbn07XG52YXIgUXVldWVkQ29tcG9uZW50UHJveHkgPSBjbGFzcyBleHRlbmRzIEJhc2VDb21wb25lbnQge1xuICBjb25zdHJ1Y3Rvcihvbk1vdW50LCBvblVubW91bnQpIHtcbiAgICBzdXBlcih7IGV2ZW50QnVzOiB7IG9uKCkge1xuICAgIH0sIGVtaXQoKSB7XG4gICAgfSB9LCBsb2dnZXI6IHsgaW5mbygpIHtcbiAgICB9LCBlcnJvcigpIHtcbiAgICB9LCBlbmFibGVkOiBmYWxzZSB9LCByb3V0ZXI6IG51bGwgfSk7XG4gICAgdGhpcy5fb25Nb3VudCA9IG9uTW91bnQ7XG4gICAgdGhpcy5fb25Vbm1vdW50ID0gb25Vbm1vdW50O1xuICB9XG4gIG1vdW50KGVsKSB7XG4gICAgdGhpcy5fb25Nb3VudChlbCk7XG4gIH1cbiAgdW5tb3VudChlbCkge1xuICAgIHRoaXMuX29uVW5tb3VudChlbCk7XG4gIH1cbn07XG52YXIgaWRsZSA9IGNyZWF0ZUlkbGUoKTtcbnZhciBQYWdlTWFuYWdlciA9IGNsYXNzIHtcbiAgY29uc3RydWN0b3IoeyBjb250YWluZXJTZWxlY3RvciwgcmVnaXN0cnksIGV2ZW50QnVzLCBsb2dnZXIsIHJvdXRlciB9KSB7XG4gICAgdGhpcy5ldmVudEJ1cyA9IGV2ZW50QnVzO1xuICAgIHRoaXMubG9nZ2VyID0gbG9nZ2VyO1xuICAgIHRoaXMucm91dGVyID0gcm91dGVyO1xuICAgIHRoaXMuY29udGFpbmVyU2VsZWN0b3IgPSBjb250YWluZXJTZWxlY3RvcjtcbiAgICB0aGlzLnJlZ2lzdHJ5ID0gcmVnaXN0cnk7XG4gICAgdGhpcy5pbnN0YW5jZXMgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICAgIHRoaXMub2JzZXJ2ZXIgPSBudWxsO1xuICAgIHRoaXMuZXZlbnRCdXMub24oXCJyb3V0ZTpzdWNjZXNzXCIsICh7IGh0bWwgfSkgPT4gdGhpcy5yZXBsYWNlRnJhZ21lbnQoaHRtbCkpO1xuICAgIHRoaXMuZXZlbnRCdXMub24oXCJyb3V0ZTpwb3BcIiwgYXN5bmMgKHsgdXJsIH0pID0+IHtcbiAgICAgIHZhciBfYSwgX2I7XG4gICAgICB0cnkge1xuICAgICAgICBjb25zdCB7IGRhdGEgfSA9IGF3YWl0IHRoaXMucm91dGVyLmdldCh1cmwudG9TdHJpbmcoKSk7XG4gICAgICAgIGlmICh0eXBlb2YgZGF0YSA9PT0gXCJzdHJpbmdcIikgdGhpcy5yZXBsYWNlRnJhZ21lbnQoZGF0YSwgeyBmcm9tUG9wOiB0cnVlIH0pO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAoX2IgPSAoX2EgPSB0aGlzLmxvZ2dlcikuZXJyb3IpID09IG51bGwgPyB2b2lkIDAgOiBfYi5jYWxsKF9hLCBcInJvdXRlOnBvcCBmZXRjaCBmYWlsZWRcIiwgZSk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbiAgZ2V0IGNvbnRhaW5lcigpIHtcbiAgICBjb25zdCBlbCA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IodGhpcy5jb250YWluZXJTZWxlY3Rvcik7XG4gICAgaWYgKCFlbCkgdGhyb3cgbmV3IEVycm9yKGBDb250YWluZXIgbm90IGZvdW5kOiAke3RoaXMuY29udGFpbmVyU2VsZWN0b3J9YCk7XG4gICAgcmV0dXJuIGVsO1xuICB9XG4gIHJlcGxhY2VGcmFnbWVudChodG1sLCB7IGZyb21Qb3AgPSBmYWxzZSB9ID0ge30pIHtcbiAgICBjb25zdCByb290ID0gdGhpcy5jb250YWluZXI7XG4gICAgdGhpcy5ldmVudEJ1cy5lbWl0KFwiZnJhZ21lbnQ6d2lsbC11bm1vdW50XCIsIHsgcm9vdCB9KTtcbiAgICB0aGlzLnVubW91bnRBbGxXaXRoaW4ocm9vdCk7XG4gICAgY29uc3QgdHBsID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInRlbXBsYXRlXCIpO1xuICAgIHRwbC5pbm5lckhUTUwgPSBodG1sLnRyaW0oKTtcbiAgICByb290LnJlcGxhY2VDaGlsZHJlbiguLi50cGwuY29udGVudC5jaGlsZE5vZGVzKTtcbiAgICB0aGlzLmV2ZW50QnVzLmVtaXQoXCJmcmFnbWVudDpkaWQtbW91bnRcIiwgeyByb290IH0pO1xuICAgIHRoaXMubW91bnRBbGxXaXRoaW4ocm9vdCk7XG4gICAgaWRsZSgoKSA9PiB0aGlzLm1vdW50QWxsV2l0aGluKHJvb3QpLCAxMjAwKTtcbiAgICBpZiAoIXRoaXMub2JzZXJ2ZXIpIHRoaXMuX3N0YXJ0T2JzZXJ2ZXIocm9vdCk7XG4gIH1cbiAgX3N0YXJ0T2JzZXJ2ZXIocm9vdCkge1xuICAgIGlmICghKFwiTXV0YXRpb25PYnNlcnZlclwiIGluIHdpbmRvdykpIHJldHVybjtcbiAgICB0aGlzLm9ic2VydmVyID0gbmV3IE11dGF0aW9uT2JzZXJ2ZXIoKG11dGF0aW9ucykgPT4ge1xuICAgICAgbGV0IGFkZGVkID0gW10sIHJlbW92ZWQgPSBbXTtcbiAgICAgIGZvciAoY29uc3QgbSBvZiBtdXRhdGlvbnMpIHtcbiAgICAgICAgaWYgKG0uYWRkZWROb2RlcykgYWRkZWQgPSBhZGRlZC5jb25jYXQoWy4uLm0uYWRkZWROb2Rlc10uZmlsdGVyKChuKSA9PiBuLm5vZGVUeXBlID09PSAxKSk7XG4gICAgICAgIGlmIChtLnJlbW92ZWROb2RlcykgcmVtb3ZlZCA9IHJlbW92ZWQuY29uY2F0KFsuLi5tLnJlbW92ZWROb2Rlc10uZmlsdGVyKChuKSA9PiBuLm5vZGVUeXBlID09PSAxKSk7XG4gICAgICB9XG4gICAgICBpZiAoYWRkZWQubGVuZ3RoKSB7XG4gICAgICAgIHRoaXMubW91bnRBbGxXaXRoaW4ocm9vdCwgYWRkZWQpO1xuICAgICAgfVxuICAgICAgaWYgKHJlbW92ZWQubGVuZ3RoKSB7XG4gICAgICAgIHRoaXMudW5tb3VudFJlbW92ZWQocmVtb3ZlZCk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgdGhpcy5vYnNlcnZlci5vYnNlcnZlKHJvb3QsIHsgY2hpbGRMaXN0OiB0cnVlLCBzdWJ0cmVlOiB0cnVlIH0pO1xuICB9XG4gIG1vdW50QWxsV2l0aGluKHJvb3QsIGFkZGVkTm9kZXMgPSBudWxsKSB7XG4gICAgdmFyIF9hLCBfYiwgX2MsIF9kO1xuICAgIChfYiA9IChfYSA9IHRoaXMubG9nZ2VyKS5ncm91cCkgPT0gbnVsbCA/IHZvaWQgMCA6IF9iLmNhbGwoX2EsIFwibW91bnRBbGxXaXRoaW5cIik7XG4gICAgdHJ5IHtcbiAgICAgIGZvciAoY29uc3QgY2ZnIG9mIHRoaXMucmVnaXN0cnkpIHtcbiAgICAgICAgY29uc3Qgc2NvcGUgPSBhZGRlZE5vZGVzID8gYWRkZWROb2RlcyA6IFtyb290XTtcbiAgICAgICAgY29uc3QgZWxzID0gc2NvcGUuZmxhdE1hcCgobm9kZSkgPT4gWy4uLm5vZGUucXVlcnlTZWxlY3RvckFsbChjZmcuc2VsZWN0b3IpXSk7XG4gICAgICAgIGlmICghZWxzLmxlbmd0aCkgY29udGludWU7XG4gICAgICAgIGNvbnN0IGluc3RhbmNlID0gdGhpcy5fZW5zdXJlSW5zdGFuY2UoY2ZnKTtcbiAgICAgICAgZm9yIChjb25zdCBlbCBvZiBlbHMpIGluc3RhbmNlLm1vdW50KGVsKTtcbiAgICAgIH1cbiAgICB9IGZpbmFsbHkge1xuICAgICAgKF9kID0gKF9jID0gdGhpcy5sb2dnZXIpLmdyb3VwRW5kKSA9PSBudWxsID8gdm9pZCAwIDogX2QuY2FsbChfYyk7XG4gICAgfVxuICB9XG4gIHVubW91bnRBbGxXaXRoaW4ocm9vdCkge1xuICAgIHZhciBfYSwgX2IsIF9jLCBfZCwgX2U7XG4gICAgKF9iID0gKF9hID0gdGhpcy5sb2dnZXIpLmdyb3VwKSA9PSBudWxsID8gdm9pZCAwIDogX2IuY2FsbChfYSwgXCJ1bm1vdW50QWxsV2l0aGluXCIpO1xuICAgIHRyeSB7XG4gICAgICBmb3IgKGNvbnN0IGluc3Qgb2YgdGhpcy5pbnN0YW5jZXMudmFsdWVzKCkpIHtcbiAgICAgICAgZm9yIChjb25zdCBlbCBvZiAoKF9jID0gaW5zdC5fZWxlbWVudHNLZXlzKSA9PSBudWxsID8gdm9pZCAwIDogX2MuY2FsbChpbnN0KSkgfHwgW10pIHtcbiAgICAgICAgICBpZiAocm9vdC5jb250YWlucyhlbCkpIGluc3QudW5tb3VudChlbCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGZpbmFsbHkge1xuICAgICAgKF9lID0gKF9kID0gdGhpcy5sb2dnZXIpLmdyb3VwRW5kKSA9PSBudWxsID8gdm9pZCAwIDogX2UuY2FsbChfZCk7XG4gICAgfVxuICB9XG4gIHVubW91bnRSZW1vdmVkKG5vZGVzKSB7XG4gICAgdmFyIF9hO1xuICAgIGZvciAoY29uc3QgaW5zdCBvZiB0aGlzLmluc3RhbmNlcy52YWx1ZXMoKSkge1xuICAgICAgZm9yIChjb25zdCBlbCBvZiAoKF9hID0gaW5zdC5fZWxlbWVudHNLZXlzKSA9PSBudWxsID8gdm9pZCAwIDogX2EuY2FsbChpbnN0KSkgfHwgW10pIHtcbiAgICAgICAgaWYgKCFkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuY29udGFpbnMoZWwpKSBpbnN0LnVubW91bnQoZWwpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBfZW5zdXJlSW5zdGFuY2UoY2ZnKSB7XG4gICAgdmFyIF9hO1xuICAgIGxldCBpbnN0ID0gdGhpcy5pbnN0YW5jZXMuZ2V0KGNmZy5uYW1lKTtcbiAgICBpZiAoaW5zdCkgcmV0dXJuIGluc3Q7XG4gICAgaWYgKChfYSA9IGNmZy5kZXBlbmRzT24pID09IG51bGwgPyB2b2lkIDAgOiBfYS5sZW5ndGgpIHtcbiAgICAgIGZvciAoY29uc3QgZGVwIG9mIGNmZy5kZXBlbmRzT24pIHtcbiAgICAgICAgY29uc3QgZGVwQ2ZnID0gdGhpcy5yZWdpc3RyeS5maW5kKChjKSA9PiBjLm5hbWUgPT09IGRlcCk7XG4gICAgICAgIGlmIChkZXBDZmcpIHRoaXMuX2Vuc3VyZUluc3RhbmNlKGRlcENmZyk7XG4gICAgICB9XG4gICAgfVxuICAgIGNvbnN0IGN0b3JQcm9taXNlTGlrZSA9IGNmZy5sb2FkZXIoKTtcbiAgICBjb25zdCBjdG9yTWF5YmUgPSBjdG9yUHJvbWlzZUxpa2UgaW5zdGFuY2VvZiBQcm9taXNlID8gbnVsbCA6IGN0b3JQcm9taXNlTGlrZTtcbiAgICBjb25zdCBjcmVhdGUgPSAoQ3RvcikgPT4ge1xuICAgICAgY29uc3QgaSA9IG5ldyBDdG9yKHsgZXZlbnRCdXM6IHRoaXMuZXZlbnRCdXMsIGxvZ2dlcjogdGhpcy5sb2dnZXIsIHJvdXRlcjogdGhpcy5yb3V0ZXIgfSk7XG4gICAgICB0aGlzLmluc3RhbmNlcy5zZXQoY2ZnLm5hbWUsIGkpO1xuICAgICAgcmV0dXJuIGk7XG4gICAgfTtcbiAgICBpZiAoY3Rvck1heWJlKSByZXR1cm4gY3JlYXRlKGN0b3JNYXliZS5kZWZhdWx0KTtcbiAgICBjb25zdCBxdWV1ZSA9IFtdO1xuICAgIGNvbnN0IHBsYWNlaG9sZGVyID0gbmV3IFF1ZXVlZENvbXBvbmVudFByb3h5KChlbCkgPT4gcXVldWUucHVzaChbXCJtb3VudFwiLCBlbF0pLCAoZWwpID0+IHF1ZXVlLnB1c2goW1widW5tb3VudFwiLCBlbF0pKTtcbiAgICB0aGlzLmluc3RhbmNlcy5zZXQoY2ZnLm5hbWUsIHBsYWNlaG9sZGVyKTtcbiAgICBjZmcubG9hZGVyKCkudGhlbigobW9kKSA9PiB7XG4gICAgICB2YXIgX2EyLCBfYjtcbiAgICAgIGNvbnN0IHJlYWwgPSBjcmVhdGUobW9kLmRlZmF1bHQpO1xuICAgICAgZm9yIChjb25zdCBbYWN0aW9uLCBlbF0gb2YgcXVldWUpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICByZWFsW2FjdGlvbl0oZWwpO1xuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgKF9iID0gKF9hMiA9IHRoaXMubG9nZ2VyKS5lcnJvcikgPT0gbnVsbCA/IHZvaWQgMCA6IF9iLmNhbGwoX2EyLCBgZGVxdWV1ZWQgJHtjZmcubmFtZX0uJHthY3Rpb259IGZhaWxlZGAsIGUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICB0aGlzLmluc3RhbmNlcy5zZXQoY2ZnLm5hbWUsIHJlYWwpO1xuICAgIH0pLmNhdGNoKChlKSA9PiB7XG4gICAgICB2YXIgX2EyLCBfYjtcbiAgICAgIHJldHVybiAoX2IgPSAoX2EyID0gdGhpcy5sb2dnZXIpLmVycm9yKSA9PSBudWxsID8gdm9pZCAwIDogX2IuY2FsbChfYTIsIGBGYWlsZWQgdG8gbG9hZCBjb21wb25lbnQgJHtjZmcubmFtZX1gLCBlKTtcbiAgICB9KTtcbiAgICByZXR1cm4gcGxhY2Vob2xkZXI7XG4gIH1cbn07XG5cbmV4cG9ydCB7IEJhc2VDb21wb25lbnQsIFBhZ2VNYW5hZ2VyLCBRdWV1ZWRDb21wb25lbnRQcm94eSB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwXG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXAiLCIvLyBzcmMvWE1vZGFsLmpzXG52YXIgWE1vZGFsID0gY2xhc3MgZXh0ZW5kcyBIVE1MRWxlbWVudCB7XG4gIHN0YXRpYyBnZXQgb2JzZXJ2ZWRBdHRyaWJ1dGVzKCkge1xuICAgIHJldHVybiBbXCJvcGVuXCJdO1xuICB9XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKCk7XG4gICAgY29uc3Qgcm9vdCA9IHRoaXMuYXR0YWNoU2hhZG93KHsgbW9kZTogXCJvcGVuXCIgfSk7XG4gICAgcm9vdC5pbm5lckhUTUwgPSBgXG4gICAgICA8c3R5bGU+XG4gICAgICAgIDpob3N0eyBkaXNwbGF5Om5vbmU7IH1cbiAgICAgICAgOmhvc3QoW29wZW5dKXsgZGlzcGxheTpibG9jazsgcG9zaXRpb246Zml4ZWQ7IGluc2V0OjA7IHotaW5kZXg6OTk5OTsgfVxuICAgICAgICAuYmFja2Ryb3B7IHBvc2l0aW9uOmFic29sdXRlOyBpbnNldDowOyBiYWNrZ3JvdW5kOnJnYmEoMCwwLDAsLjQ1KTsgfVxuICAgICAgICAucGFuZWx7IHBvc2l0aW9uOmFic29sdXRlOyBpbnNldDphdXRvOyB0b3A6NTAlOyBsZWZ0OjUwJTsgdHJhbnNmb3JtOnRyYW5zbGF0ZSgtNTAlLC01MCUpO1xuICAgICAgICAgICAgICAgIG1pbi13aWR0aDogbWluKDkydncsIDY0MHB4KTsgbWF4LXdpZHRoOiA5MnZ3OyBtYXgtaGVpZ2h0OiA4NnZoOyBvdmVyZmxvdzphdXRvO1xuICAgICAgICAgICAgICAgIGJhY2tncm91bmQ6IzBmMTcyYTsgY29sb3I6I2U1ZTdlYjsgYm9yZGVyOjFweCBzb2xpZCByZ2JhKDI1NSwyNTUsMjU1LC4wOCk7IGJvcmRlci1yYWRpdXM6MTZweDsgYm94LXNoYWRvdzowIDIwcHggNjBweCByZ2JhKDAsMCwwLC41KTsgfVxuICAgICAgICBoZWFkZXJ7IGRpc3BsYXk6ZmxleDsgYWxpZ24taXRlbXM6Y2VudGVyOyBnYXA6OHB4OyBwYWRkaW5nOjEycHggMTRweDsgYm9yZGVyLWJvdHRvbToxcHggc29saWQgcmdiYSgyNTUsMjU1LDI1NSwuMDgpOyBwb3NpdGlvbjpzdGlja3k7IHRvcDowOyBiYWNrZ3JvdW5kOiMwZjE3MmE7IH1cbiAgICAgICAgaGVhZGVyIGgyeyBtYXJnaW46MDsgZm9udC1zaXplOjE4cHg7IGxpbmUtaGVpZ2h0OjEuMzsgfVxuICAgICAgICAuc3BhY2VyeyBmbGV4OjE7IH1cbiAgICAgICAgYnV0dG9uLmljb257IGFsbDp1bnNldDsgZGlzcGxheTppbmxpbmUtZmxleDsgYWxpZ24taXRlbXM6Y2VudGVyOyBqdXN0aWZ5LWNvbnRlbnQ6Y2VudGVyOyB3aWR0aDoyOHB4OyBoZWlnaHQ6MjhweDsgYm9yZGVyLXJhZGl1czo4cHg7IGN1cnNvcjpwb2ludGVyOyB9XG4gICAgICAgIHNlY3Rpb257IHBhZGRpbmc6MTRweDsgfVxuICAgICAgICBmb290ZXJ7IHBhZGRpbmc6MTJweCAxNHB4OyBib3JkZXItdG9wOjFweCBzb2xpZCByZ2JhKDI1NSwyNTUsMjU1LC4wOCk7IGRpc3BsYXk6ZmxleDsgZ2FwOjhweDsganVzdGlmeS1jb250ZW50OmZsZXgtZW5kOyBwb3NpdGlvbjpzdGlja3k7IGJvdHRvbTowOyBiYWNrZ3JvdW5kOiMwZjE3MmE7IH1cbiAgICAgICAgOjpzbG90dGVkKC5idG4peyBhcHBlYXJhbmNlOm5vbmU7IGJvcmRlcjowOyBib3JkZXItcmFkaXVzOjEwcHg7IHBhZGRpbmc6MTBweCAxNHB4OyBiYWNrZ3JvdW5kOiMxZjI5Mzc7IGNvbG9yOiNmZmY7IGN1cnNvcjpwb2ludGVyOyB9XG4gICAgICAgIDo6c2xvdHRlZCguYnRuLmFjY2VudCl7IGJhY2tncm91bmQ6IzYwYTVmYTsgY29sb3I6IzBiMTAyMDsgZm9udC13ZWlnaHQ6NzAwOyB9XG4gICAgICA8L3N0eWxlPlxuICAgICAgPGRpdiBjbGFzcz1cImJhY2tkcm9wXCIgcGFydD1cImJhY2tkcm9wXCI+PC9kaXY+XG4gICAgICA8ZGl2IGNsYXNzPVwicGFuZWxcIiBwYXJ0PVwicGFuZWxcIiByb2xlPVwiZGlhbG9nXCIgYXJpYS1tb2RhbD1cInRydWVcIj5cbiAgICAgICAgPGhlYWRlciBwYXJ0PVwiaGVhZGVyXCI+XG4gICAgICAgICAgPHNsb3QgbmFtZT1cInRpdGxlXCI+PGgyPkRpYWxvZzwvaDI+PC9zbG90PlxuICAgICAgICAgIDxkaXYgY2xhc3M9XCJzcGFjZXJcIj48L2Rpdj5cbiAgICAgICAgICA8YnV0dG9uIGNsYXNzPVwiaWNvblwiIGFyaWEtbGFiZWw9XCJDbG9zZVwiIHBhcnQ9XCJjbG9zZVwiPlxceEQ3PC9idXR0b24+XG4gICAgICAgIDwvaGVhZGVyPlxuICAgICAgICA8c2VjdGlvbiBwYXJ0PVwiY29udGVudFwiPjxzbG90Pjwvc2xvdD48L3NlY3Rpb24+XG4gICAgICAgIDxmb290ZXIgcGFydD1cImZvb3RlclwiPjxzbG90IG5hbWU9XCJhY3Rpb25zXCI+PC9zbG90PjwvZm9vdGVyPlxuICAgICAgPC9kaXY+XG4gICAgYDtcbiAgICB0aGlzLl9lbHMgPSB7XG4gICAgICBiYWNrZHJvcDogcm9vdC5xdWVyeVNlbGVjdG9yKFwiLmJhY2tkcm9wXCIpLFxuICAgICAgcGFuZWw6IHJvb3QucXVlcnlTZWxlY3RvcihcIi5wYW5lbFwiKSxcbiAgICAgIGNsb3NlOiByb290LnF1ZXJ5U2VsZWN0b3IoXCJidXR0b24uaWNvblwiKVxuICAgIH07XG4gICAgdGhpcy5fb25LZXlkb3duID0gdGhpcy5fb25LZXlkb3duLmJpbmQodGhpcyk7XG4gICAgdGhpcy5fb25Gb2N1cyA9IHRoaXMuX29uRm9jdXMuYmluZCh0aGlzKTtcbiAgfVxuICBjb25uZWN0ZWRDYWxsYmFjaygpIHtcbiAgICB0aGlzLl91cGdyYWRlUHJvcGVydHkoXCJvcGVuXCIpO1xuICAgIHRoaXMuX2Vscy5iYWNrZHJvcC5hZGRFdmVudExpc3RlbmVyKFwiY2xpY2tcIiwgKCkgPT4gdGhpcy5fY2xvc2FibGUoKSAmJiB0aGlzLmNsb3NlKCkpO1xuICAgIHRoaXMuX2Vscy5jbG9zZS5hZGRFdmVudExpc3RlbmVyKFwiY2xpY2tcIiwgKCkgPT4gdGhpcy5fY2xvc2FibGUoKSAmJiB0aGlzLmNsb3NlKCkpO1xuICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJrZXlkb3duXCIsIHRoaXMuX29uS2V5ZG93bik7XG4gICAgdGhpcy5hZGRFdmVudExpc3RlbmVyKFwiZm9jdXNpblwiLCB0aGlzLl9vbkZvY3VzKTtcbiAgfVxuICBkaXNjb25uZWN0ZWRDYWxsYmFjaygpIHtcbiAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKFwia2V5ZG93blwiLCB0aGlzLl9vbktleWRvd24pO1xuICAgIHRoaXMucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImZvY3VzaW5cIiwgdGhpcy5fb25Gb2N1cyk7XG4gIH1cbiAgYXR0cmlidXRlQ2hhbmdlZENhbGxiYWNrKG5hbWUpIHtcbiAgICBpZiAobmFtZSA9PT0gXCJvcGVuXCIpIHtcbiAgICAgIGlmICh0aGlzLmhhc0F0dHJpYnV0ZShcIm9wZW5cIikpIHtcbiAgICAgICAgdGhpcy5kaXNwYXRjaEV2ZW50KG5ldyBDdXN0b21FdmVudChcIm9wZW5cIiwgeyBidWJibGVzOiB0cnVlIH0pKTtcbiAgICAgICAgY29uc3QgZiA9IHRoaXMuX2ZpcnN0Rm9jdXNhYmxlKCk7XG4gICAgICAgIChmIHx8IHRoaXMuX2Vscy5jbG9zZSkuZm9jdXMoeyBwcmV2ZW50U2Nyb2xsOiB0cnVlIH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5kaXNwYXRjaEV2ZW50KG5ldyBDdXN0b21FdmVudChcImNsb3NlXCIsIHsgYnViYmxlczogdHJ1ZSB9KSk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIG9wZW4oKSB7XG4gICAgdGhpcy5zZXRBdHRyaWJ1dGUoXCJvcGVuXCIsIFwiXCIpO1xuICB9XG4gIGNsb3NlKCkge1xuICAgIHRoaXMucmVtb3ZlQXR0cmlidXRlKFwib3BlblwiKTtcbiAgfVxuICB0b2dnbGUoZm9yY2UpIHtcbiAgICBpZiAoZm9yY2UgPT09IHRydWUpIHRoaXMub3BlbigpO1xuICAgIGVsc2UgaWYgKGZvcmNlID09PSBmYWxzZSkgdGhpcy5jbG9zZSgpO1xuICAgIGVsc2UgdGhpcy5oYXNBdHRyaWJ1dGUoXCJvcGVuXCIpID8gdGhpcy5jbG9zZSgpIDogdGhpcy5vcGVuKCk7XG4gIH1cbiAgX2Nsb3NhYmxlKCkge1xuICAgIHJldHVybiB0aGlzLmdldEF0dHJpYnV0ZShcImNsb3NhYmxlXCIpICE9PSBcImZhbHNlXCI7XG4gIH1cbiAgX3VwZ3JhZGVQcm9wZXJ0eShwcm9wKSB7XG4gICAgaWYgKHRoaXMuaGFzT3duUHJvcGVydHkocHJvcCkpIHtcbiAgICAgIGxldCB2ID0gdGhpc1twcm9wXTtcbiAgICAgIGRlbGV0ZSB0aGlzW3Byb3BdO1xuICAgICAgdGhpc1twcm9wXSA9IHY7XG4gICAgfVxuICB9XG4gIF9vbktleWRvd24oZSkge1xuICAgIGlmICghdGhpcy5oYXNBdHRyaWJ1dGUoXCJvcGVuXCIpKSByZXR1cm47XG4gICAgaWYgKGUua2V5ID09PSBcIkVzY2FwZVwiICYmIHRoaXMuX2Nsb3NhYmxlKCkpIHtcbiAgICAgIHRoaXMuY2xvc2UoKTtcbiAgICB9XG4gICAgaWYgKGUua2V5ID09PSBcIlRhYlwiKSB7XG4gICAgICB0aGlzLl90cmFwVGFiKGUpO1xuICAgIH1cbiAgfVxuICBfb25Gb2N1cygpIHtcbiAgICBpZiAoIXRoaXMuY29udGFpbnMoZG9jdW1lbnQuYWN0aXZlRWxlbWVudCkpIHtcbiAgICAgICh0aGlzLl9maXJzdEZvY3VzYWJsZSgpIHx8IHRoaXMuX2Vscy5jbG9zZSkuZm9jdXMoeyBwcmV2ZW50U2Nyb2xsOiB0cnVlIH0pO1xuICAgIH1cbiAgfVxuICBfZm9jdXNhYmxlcygpIHtcbiAgICBjb25zdCBzZWwgPSBbXCJhW2hyZWZdXCIsIFwiYnV0dG9uXCIsIFwiaW5wdXRcIiwgXCJzZWxlY3RcIiwgXCJ0ZXh0YXJlYVwiLCAnW3RhYmluZGV4XTpub3QoW3RhYmluZGV4PVwiLTFcIl0pJ10uam9pbihcIixcIik7XG4gICAgcmV0dXJuIFsuLi50aGlzLnF1ZXJ5U2VsZWN0b3JBbGwoc2VsKV0uZmlsdGVyKChlbCkgPT4gIWVsLmhhc0F0dHJpYnV0ZShcImRpc2FibGVkXCIpKTtcbiAgfVxuICBfZmlyc3RGb2N1c2FibGUoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2ZvY3VzYWJsZXMoKVswXTtcbiAgfVxuICBfdHJhcFRhYihlKSB7XG4gICAgY29uc3QgZiA9IHRoaXMuX2ZvY3VzYWJsZXMoKTtcbiAgICBpZiAoIWYubGVuZ3RoKSByZXR1cm47XG4gICAgY29uc3QgZmlyc3QgPSBmWzBdLCBsYXN0ID0gZltmLmxlbmd0aCAtIDFdO1xuICAgIGNvbnN0IGFjdGl2ZSA9IHRoaXMuY29udGFpbnMoZG9jdW1lbnQuYWN0aXZlRWxlbWVudCkgPyBkb2N1bWVudC5hY3RpdmVFbGVtZW50IDogbnVsbDtcbiAgICBpZiAoZS5zaGlmdEtleSkge1xuICAgICAgaWYgKGFjdGl2ZSA9PT0gZmlyc3QgfHwgIWFjdGl2ZSkge1xuICAgICAgICBsYXN0LmZvY3VzKCk7XG4gICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKGFjdGl2ZSA9PT0gbGFzdCkge1xuICAgICAgICBmaXJzdC5mb2N1cygpO1xuICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICB9XG4gICAgfVxuICB9XG59O1xuaWYgKCFjdXN0b21FbGVtZW50cy5nZXQoXCJ4LW1vZGFsXCIpKSBjdXN0b21FbGVtZW50cy5kZWZpbmUoXCJ4LW1vZGFsXCIsIFhNb2RhbCk7XG5cbmV4cG9ydCB7IFhNb2RhbCB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwXG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXAiLCIvLyBzcmMvWFRvYXN0cy5qc1xudmFyIFhUb2FzdHMgPSBjbGFzcyBleHRlbmRzIEhUTUxFbGVtZW50IHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoKTtcbiAgICBjb25zdCByb290ID0gdGhpcy5hdHRhY2hTaGFkb3coeyBtb2RlOiBcIm9wZW5cIiB9KTtcbiAgICByb290LmlubmVySFRNTCA9IGBcbiAgICAgIDxzdHlsZT5cbiAgICAgICAgOmhvc3R7cG9zaXRpb246Zml4ZWQ7IGluc2V0OmF1dG8gYXV0byBhdXRvIDA7IHBhZGRpbmc6MTJweDsgei1pbmRleDoyMTQ3NDgzNjQ3OyBkaXNwbGF5OmdyaWQ7IGdhcDo4cHg7fVxuICAgICAgICA6aG9zdChbcGxhY2VtZW50PVwidG9wLWxlZnRcIl0peyB0b3A6MDsgbGVmdDowOyB9XG4gICAgICAgIDpob3N0KFtwbGFjZW1lbnQ9XCJ0b3AtcmlnaHRcIl0peyB0b3A6MDsgcmlnaHQ6MDsgbGVmdDphdXRvOyB9XG4gICAgICAgIDpob3N0KFtwbGFjZW1lbnQ9XCJib3R0b20tcmlnaHRcIl0peyBib3R0b206MDsgcmlnaHQ6MDsgbGVmdDphdXRvOyB9XG4gICAgICAgIDpob3N0KFtwbGFjZW1lbnQ9XCJib3R0b20tbGVmdFwiXSl7IGJvdHRvbTowOyBsZWZ0OjA7IH1cbiAgICAgICAgLnRvYXN0eyBwYWRkaW5nOjEwcHggMTJweDsgYm9yZGVyLXJhZGl1czo4cHg7IGNvbG9yOiNmZmY7IGJveC1zaGFkb3c6MCA2cHggMjBweCByZ2JhKDAsMCwwLC4yNSk7IG9wYWNpdHk6MDsgdHJhbnNmb3JtOiB0cmFuc2xhdGVZKC02cHgpO1xuICAgICAgICAgICAgICAgIGFuaW1hdGlvbjogaW4gLjE4cyBlYXNlLW91dCBmb3J3YXJkczsgY3Vyc29yOnBvaW50ZXI7IGZvbnQ6IDE0cHgvMS40IHN5c3RlbS11aSwgLWFwcGxlLXN5c3RlbSwgU2Vnb2UgVUksIFJvYm90bywgc2Fucy1zZXJpZjsgb3V0bGluZTpub25lO31cbiAgICAgICAgLnRvYXN0LmluZm97IGJhY2tncm91bmQ6IzExMTgyNzsgfVxuICAgICAgICAudG9hc3Quc3VjY2Vzc3sgYmFja2dyb3VuZDojMDY1ZjQ2OyB9XG4gICAgICAgIC50b2FzdC53YXJueyBiYWNrZ3JvdW5kOiM3YzJkMTI7IH1cbiAgICAgICAgLnRvYXN0LmVycm9yeyBiYWNrZ3JvdW5kOiM3ZjFkMWQ7IH1cbiAgICAgICAgLnRvYXN0LmxvYWRpbmd7IGJhY2tncm91bmQ6IzBmMTcyYTsgfVxuICAgICAgICBAa2V5ZnJhbWVzIGlueyB0b3sgb3BhY2l0eToxOyB0cmFuc2Zvcm06bm9uZTsgfSB9XG4gICAgICAgIEBrZXlmcmFtZXMgb3V0eyB0b3sgb3BhY2l0eTowOyB0cmFuc2Zvcm06IHRyYW5zbGF0ZVkoLTZweCk7IH0gfVxuICAgICAgICAucm93eyBkaXNwbGF5OmZsZXg7IGFsaWduLWl0ZW1zOmNlbnRlcjsgZ2FwOjhweDsgfVxuICAgICAgICAubXNneyB3aGl0ZS1zcGFjZTpwcmUtd3JhcDsgfVxuICAgICAgICBidXR0b24uaWNvbnsgYWxsOnVuc2V0OyBkaXNwbGF5OmlubGluZS1mbGV4OyBhbGlnbi1pdGVtczpjZW50ZXI7IGp1c3RpZnktY29udGVudDpjZW50ZXI7IHdpZHRoOjI0cHg7IGhlaWdodDoyNHB4OyBib3JkZXItcmFkaXVzOjZweDsgZm9udC13ZWlnaHQ6NzAwOyB9XG4gICAgICAgIGJ1dHRvbi5hY3Rpb257IGFsbDp1bnNldDsgcGFkZGluZzo0cHggOHB4OyBib3JkZXItcmFkaXVzOjZweDsgYmFja2dyb3VuZDpyZ2JhKDI1NSwyNTUsMjU1LC4xNSk7IGZvbnQtd2VpZ2h0OjYwMDsgfVxuICAgICAgICAuc3BhY2VyeyBmbGV4OjE7IH1cbiAgICAgICAgLmJhcnsgcG9zaXRpb246cmVsYXRpdmU7IGhlaWdodDo2cHg7IGJvcmRlci1yYWRpdXM6OTk5cHg7IG92ZXJmbG93OmhpZGRlbjsgYmFja2dyb3VuZDogcmdiYSgyNTUsMjU1LDI1NSwuMTgpOyBtYXJnaW4tdG9wOjhweDsgfVxuICAgICAgICAuYmFyID4gLmZpbGx7IHBvc2l0aW9uOmFic29sdXRlOyBpbnNldDowIGF1dG8gMCAwOyB3aWR0aDowJTsgYmFja2dyb3VuZDogcmdiYSgyNTUsMjU1LDI1NSwuODUpOyBib3JkZXItcmFkaXVzOmluaGVyaXQ7IH1cbiAgICAgICAgLmJhci5pbmRldGVybWluYXRlID4gLmZpbGx7IHdpZHRoOjQwJTsgYW5pbWF0aW9uOiBpbmRldCAxLjJzIGVhc2UtaW4tb3V0IGluZmluaXRlOyB9XG4gICAgICAgIEBrZXlmcmFtZXMgaW5kZXQgeyAwJXsgbGVmdDotNDAlOyB9IDUwJXsgbGVmdDo2MCU7IH0gMTAwJXsgbGVmdDoxMDAlOyB9IH1cbiAgICAgICAgLnNwaW57IHdpZHRoOjE2cHg7IGhlaWdodDoxNnB4OyBib3JkZXItcmFkaXVzOjUwJTsgYm9yZGVyOjJweCBzb2xpZCByZ2JhKDI1NSwyNTUsMjU1LC4zNSk7IGJvcmRlci10b3AtY29sb3I6I2ZmZjsgYW5pbWF0aW9uOiBzcGluIC44cyBsaW5lYXIgaW5maW5pdGU7IH1cbiAgICAgICAgQGtleWZyYW1lcyBzcGlueyB0b3sgdHJhbnNmb3JtOiByb3RhdGUoMzYwZGVnKTsgfSB9XG4gICAgICA8L3N0eWxlPlxuICAgICAgPGRpdiBpZD1cIndyYXBcIiByb2xlPVwicmVnaW9uXCIgYXJpYS1saXZlPVwicG9saXRlXCI+PC9kaXY+YDtcbiAgICB0aGlzLl93cmFwID0gcm9vdC5nZXRFbGVtZW50QnlJZChcIndyYXBcIik7XG4gICAgdGhpcy5faWQgPSAwO1xuICB9XG4gIHRvYXN0KHsgbWVzc2FnZSwgdHlwZSA9IFwiaW5mb1wiLCB0aW1lb3V0ID0gNGUzLCBhbGxvd0hUTUwgPSBmYWxzZSwgYWN0aW9uIH0pIHtcbiAgICBjb25zdCBpZCA9ICsrdGhpcy5faWQ7XG4gICAgY29uc3QgZWwgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICAgIGVsLmNsYXNzTmFtZSA9IGB0b2FzdCAke3R5cGV9YDtcbiAgICBjb25zdCByb2xlID0gdHlwZSA9PT0gXCJ3YXJuXCIgfHwgdHlwZSA9PT0gXCJlcnJvclwiID8gXCJhbGVydFwiIDogXCJzdGF0dXNcIjtcbiAgICBlbC5zZXRBdHRyaWJ1dGUoXCJyb2xlXCIsIHJvbGUpO1xuICAgIGVsLnRhYkluZGV4ID0gMDtcbiAgICBjb25zdCByb3cgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICAgIHJvdy5jbGFzc05hbWUgPSBcInJvd1wiO1xuICAgIGNvbnN0IHNwYW4gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwic3BhblwiKTtcbiAgICBzcGFuLmNsYXNzTmFtZSA9IFwibXNnXCI7XG4gICAgaWYgKGFsbG93SFRNTCkgc3Bhbi5pbm5lckhUTUwgPSBtZXNzYWdlO1xuICAgIGVsc2Ugc3Bhbi50ZXh0Q29udGVudCA9IG1lc3NhZ2U7XG4gICAgY29uc3Qgc3BhY2VyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgICBzcGFjZXIuY2xhc3NOYW1lID0gXCJzcGFjZXJcIjtcbiAgICBsZXQgYWN0aW9uQnRuID0gbnVsbDtcbiAgICBpZiAoYWN0aW9uID09IG51bGwgPyB2b2lkIDAgOiBhY3Rpb24ubGFiZWwpIHtcbiAgICAgIGFjdGlvbkJ0biA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJidXR0b25cIik7XG4gICAgICBhY3Rpb25CdG4uY2xhc3NOYW1lID0gXCJhY3Rpb25cIjtcbiAgICAgIGFjdGlvbkJ0bi50eXBlID0gXCJidXR0b25cIjtcbiAgICAgIGFjdGlvbkJ0bi50ZXh0Q29udGVudCA9IGFjdGlvbi5sYWJlbDtcbiAgICAgIGFjdGlvbkJ0bi5hZGRFdmVudExpc3RlbmVyKFwiY2xpY2tcIiwgKGV2KSA9PiB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgdGhpcy5kaXNwYXRjaEV2ZW50KG5ldyBDdXN0b21FdmVudChcInRvYXN0OmFjdGlvblwiLCB7IGRldGFpbDogeyBpZCwgdHlwZSwgbWVzc2FnZSB9LCBidWJibGVzOiB0cnVlIH0pKTtcbiAgICAgICAgKF9hID0gYWN0aW9uLm9uQ2xpY2spID09IG51bGwgPyB2b2lkIDAgOiBfYS5jYWxsKGFjdGlvbiwgZXYpO1xuICAgICAgICByZW1vdmUoKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgICBjb25zdCBjbG9zZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJidXR0b25cIik7XG4gICAgY2xvc2UuY2xhc3NOYW1lID0gXCJpY29uXCI7XG4gICAgY2xvc2Uuc2V0QXR0cmlidXRlKFwiYXJpYS1sYWJlbFwiLCBcIkRpc21pc3Mgbm90aWZpY2F0aW9uXCIpO1xuICAgIGNsb3NlLnRleHRDb250ZW50ID0gXCJcXHhEN1wiO1xuICAgIHJvdy5hcHBlbmQoc3Bhbiwgc3BhY2VyKTtcbiAgICBpZiAoYWN0aW9uQnRuKSByb3cuYXBwZW5kKGFjdGlvbkJ0bik7XG4gICAgcm93LmFwcGVuZChjbG9zZSk7XG4gICAgZWwuYXBwZW5kKHJvdyk7XG4gICAgdGhpcy5fd3JhcC5hcHBlbmQoZWwpO1xuICAgIGNvbnN0IHJlbW92ZU5vdyA9ICgpID0+IHtcbiAgICAgIGVsLnN0eWxlLmFuaW1hdGlvbiA9IFwib3V0IC4xNXMgZWFzZS1pbiBmb3J3YXJkc1wiO1xuICAgICAgc2V0VGltZW91dCgoKSA9PiBlbC5yZW1vdmUoKSwgMTUwKTtcbiAgICB9O1xuICAgIGxldCByZW1vdmVkID0gZmFsc2U7XG4gICAgY29uc3QgcmVtb3ZlID0gKCkgPT4ge1xuICAgICAgaWYgKHJlbW92ZWQpIHJldHVybjtcbiAgICAgIHJlbW92ZWQgPSB0cnVlO1xuICAgICAgcmVtb3ZlTm93KCk7XG4gICAgICB0aGlzLmRpc3BhdGNoRXZlbnQobmV3IEN1c3RvbUV2ZW50KFwidG9hc3Q6Y2xvc2VcIiwgeyBkZXRhaWw6IHsgaWQsIHR5cGUsIG1lc3NhZ2UgfSwgYnViYmxlczogdHJ1ZSB9KSk7XG4gICAgfTtcbiAgICBjb25zdCB0aWQgPSB0aW1lb3V0ID8gc2V0VGltZW91dChyZW1vdmUsIHRpbWVvdXQpIDogbnVsbDtcbiAgICBjb25zdCBjYW5jZWxUaW1lciA9ICgpID0+IHRpZCAmJiBjbGVhclRpbWVvdXQodGlkKTtcbiAgICBjbG9zZS5hZGRFdmVudExpc3RlbmVyKFwiY2xpY2tcIiwgcmVtb3ZlKTtcbiAgICBlbC5hZGRFdmVudExpc3RlbmVyKFwibW91c2VlbnRlclwiLCBjYW5jZWxUaW1lcik7XG4gICAgZWwuYWRkRXZlbnRMaXN0ZW5lcihcImZvY3VzaW5cIiwgY2FuY2VsVGltZXIpO1xuICAgIGVsLmFkZEV2ZW50TGlzdGVuZXIoXCJtb3VzZWxlYXZlXCIsICgpID0+IHtcbiAgICAgIGlmICh0aW1lb3V0ICYmICFyZW1vdmVkKSBzZXRUaW1lb3V0KHJlbW92ZSwgMWUzKTtcbiAgICB9KTtcbiAgICB0aGlzLmRpc3BhdGNoRXZlbnQobmV3IEN1c3RvbUV2ZW50KFwidG9hc3Q6c2hvd1wiLCB7IGRldGFpbDogeyBpZCwgdHlwZSwgbWVzc2FnZSB9LCBidWJibGVzOiB0cnVlIH0pKTtcbiAgICByZXR1cm4gcmVtb3ZlO1xuICB9XG4gIHByb2dyZXNzKHsgbWVzc2FnZSwgZGV0ZXJtaW5hdGUgPSBmYWxzZSwgdmFsdWUgPSAwLCBtYXggPSAxMDAsIGNhbmNlbGxhYmxlID0gZmFsc2UsIG9uQ2FuY2VsIH0pIHtcbiAgICBjb25zdCBpZCA9ICsrdGhpcy5faWQ7XG4gICAgY29uc3QgZWwgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICAgIGVsLmNsYXNzTmFtZSA9IFwidG9hc3QgbG9hZGluZ1wiO1xuICAgIGVsLnNldEF0dHJpYnV0ZShcInJvbGVcIiwgXCJzdGF0dXNcIik7XG4gICAgZWwudGFiSW5kZXggPSAwO1xuICAgIGNvbnN0IHJvdyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gICAgcm93LmNsYXNzTmFtZSA9IFwicm93XCI7XG4gICAgY29uc3Qgc3BpbiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gICAgc3Bpbi5jbGFzc05hbWUgPSBcInNwaW5cIjtcbiAgICByb3cuYXBwZW5kKHNwaW4pO1xuICAgIGNvbnN0IHNwYW4gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwic3BhblwiKTtcbiAgICBzcGFuLmNsYXNzTmFtZSA9IFwibXNnXCI7XG4gICAgc3Bhbi50ZXh0Q29udGVudCA9IG1lc3NhZ2U7XG4gICAgcm93LmFwcGVuZChzcGFuKTtcbiAgICBjb25zdCBzcGFjZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICAgIHNwYWNlci5jbGFzc05hbWUgPSBcInNwYWNlclwiO1xuICAgIHJvdy5hcHBlbmQoc3BhY2VyKTtcbiAgICBjb25zdCBjbG9zZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJidXR0b25cIik7XG4gICAgY2xvc2UuY2xhc3NOYW1lID0gXCJpY29uXCI7XG4gICAgY2xvc2Uuc2V0QXR0cmlidXRlKFwiYXJpYS1sYWJlbFwiLCBjYW5jZWxsYWJsZSA/IFwiQ2FuY2VsXCIgOiBcIkRpc21pc3NcIik7XG4gICAgY2xvc2UudGV4dENvbnRlbnQgPSBcIlxcdTJBMkZcIjtcbiAgICByb3cuYXBwZW5kKGNsb3NlKTtcbiAgICBlbC5hcHBlbmQocm93KTtcbiAgICBjb25zdCBiYXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICAgIGJhci5jbGFzc05hbWUgPSBcImJhclwiICsgKGRldGVybWluYXRlID8gXCJcIiA6IFwiIGluZGV0ZXJtaW5hdGVcIik7XG4gICAgY29uc3QgZmlsbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gICAgZmlsbC5jbGFzc05hbWUgPSBcImZpbGxcIjtcbiAgICBiYXIuYXBwZW5kKGZpbGwpO1xuICAgIGVsLmFwcGVuZChiYXIpO1xuICAgIHRoaXMuX3dyYXAuYXBwZW5kKGVsKTtcbiAgICBjb25zdCBzZXQgPSAobikgPT4ge1xuICAgICAgaWYgKCFkZXRlcm1pbmF0ZSkgcmV0dXJuO1xuICAgICAgY29uc3QgcGN0ID0gTWF0aC5tYXgoMCwgTWF0aC5taW4oMTAwLCBuIC8gbWF4ICogMTAwKSk7XG4gICAgICBmaWxsLnN0eWxlLndpZHRoID0gcGN0ICsgXCIlXCI7XG4gICAgfTtcbiAgICBpZiAoZGV0ZXJtaW5hdGUpIHNldCh2YWx1ZSk7XG4gICAgY29uc3QgZGlzbWlzcyA9ICgpID0+IGVsLnJlbW92ZSgpO1xuICAgIGNvbnN0IHN1Y2NlZWQgPSAobSkgPT4ge1xuICAgICAgaWYgKG0pIHNwYW4udGV4dENvbnRlbnQgPSBtO1xuICAgICAgZWwuY2xhc3NMaXN0LmFkZChcInN1Y2Nlc3NcIik7XG4gICAgICBzZXRUaW1lb3V0KGRpc21pc3MsIDEyMDApO1xuICAgIH07XG4gICAgY29uc3QgZmFpbCA9IChtKSA9PiB7XG4gICAgICBpZiAobSkgc3Bhbi50ZXh0Q29udGVudCA9IG07XG4gICAgICBlbC5jbGFzc0xpc3QuYWRkKFwiZXJyb3JcIik7XG4gICAgICBzZXRUaW1lb3V0KGRpc21pc3MsIDE2MDApO1xuICAgIH07XG4gICAgY2xvc2UuYWRkRXZlbnRMaXN0ZW5lcihcImNsaWNrXCIsICgpID0+IHtcbiAgICAgIGlmIChjYW5jZWxsYWJsZSAmJiBvbkNhbmNlbCkgb25DYW5jZWwoKTtcbiAgICAgIGRpc21pc3MoKTtcbiAgICB9KTtcbiAgICB0aGlzLmRpc3BhdGNoRXZlbnQobmV3IEN1c3RvbUV2ZW50KFwidG9hc3Q6c2hvd1wiLCB7IGRldGFpbDogeyBpZCwgdHlwZTogXCJsb2FkaW5nXCIsIG1lc3NhZ2UgfSwgYnViYmxlczogdHJ1ZSB9KSk7XG4gICAgcmV0dXJuIHsgaWQsIHNldCwgc2V0TWVzc2FnZTogKG0pID0+IHNwYW4udGV4dENvbnRlbnQgPSBtLCBzdWNjZWVkLCBmYWlsLCBkaXNtaXNzIH07XG4gIH1cbn07XG5pZiAoIWN1c3RvbUVsZW1lbnRzLmdldChcIngtdG9hc3RzXCIpKSBjdXN0b21FbGVtZW50cy5kZWZpbmUoXCJ4LXRvYXN0c1wiLCBYVG9hc3RzKTtcblxuLy8gc3JjL0FsZXJ0TWFuYWdlci5qc1xudmFyIEFsZXJ0TWFuYWdlciA9IGNsYXNzIHtcbiAgY29uc3RydWN0b3IoeyBsb2dnZXIsIGV2ZW50QnVzLCBwbGFjZW1lbnQgPSBcInRvcC1yaWdodFwiIH0pIHtcbiAgICB0aGlzLmxvZ2dlciA9IGxvZ2dlcjtcbiAgICB0aGlzLmV2ZW50QnVzID0gZXZlbnRCdXM7XG4gICAgdGhpcy5lbCA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoXCJ4LXRvYXN0c1wiKSB8fCBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJ4LXRvYXN0c1wiKSk7XG4gICAgdGhpcy5lbC5zZXRBdHRyaWJ1dGUoXCJwbGFjZW1lbnRcIiwgcGxhY2VtZW50KTtcbiAgICB0aGlzLmVsLmFkZEV2ZW50TGlzdGVuZXIoXCJ0b2FzdDpzaG93XCIsIChlKSA9PiB7XG4gICAgICB2YXIgX2EsIF9iO1xuICAgICAgY29uc3QgZCA9IGUuZGV0YWlsO1xuICAgICAgKF9iID0gKF9hID0gdGhpcy5sb2dnZXIpLmluZm8pID09IG51bGwgPyB2b2lkIDAgOiBfYi5jYWxsKF9hLCBcInRvYXN0OnNob3dcIiwgZCk7XG4gICAgICB0aGlzLmV2ZW50QnVzLmVtaXQoXCJhbGVydHM6c2hvd1wiLCBkKTtcbiAgICB9KTtcbiAgICB0aGlzLmVsLmFkZEV2ZW50TGlzdGVuZXIoXCJ0b2FzdDpjbG9zZVwiLCAoZSkgPT4ge1xuICAgICAgdmFyIF9hLCBfYjtcbiAgICAgIGNvbnN0IGQgPSBlLmRldGFpbDtcbiAgICAgIChfYiA9IChfYSA9IHRoaXMubG9nZ2VyKS5pbmZvKSA9PSBudWxsID8gdm9pZCAwIDogX2IuY2FsbChfYSwgXCJ0b2FzdDpjbG9zZVwiLCBkKTtcbiAgICAgIHRoaXMuZXZlbnRCdXMuZW1pdChcImFsZXJ0czpjbG9zZVwiLCBkKTtcbiAgICB9KTtcbiAgICB0aGlzLmVsLmFkZEV2ZW50TGlzdGVuZXIoXCJ0b2FzdDphY3Rpb25cIiwgKGUpID0+IHtcbiAgICAgIHZhciBfYSwgX2I7XG4gICAgICBjb25zdCBkID0gZS5kZXRhaWw7XG4gICAgICAoX2IgPSAoX2EgPSB0aGlzLmxvZ2dlcikuaW5mbykgPT0gbnVsbCA/IHZvaWQgMCA6IF9iLmNhbGwoX2EsIFwidG9hc3Q6YWN0aW9uXCIsIGQpO1xuICAgICAgdGhpcy5ldmVudEJ1cy5lbWl0KFwiYWxlcnRzOmFjdGlvblwiLCBkKTtcbiAgICB9KTtcbiAgfVxuICB0b2FzdChvcHRzKSB7XG4gICAgdmFyIF9hLCBfYjtcbiAgICBjb25zdCBkaXNtaXNzID0gdGhpcy5lbC50b2FzdChvcHRzKTtcbiAgICAoX2IgPSAoX2EgPSB0aGlzLmxvZ2dlcikuaW5mbykgPT0gbnVsbCA/IHZvaWQgMCA6IF9iLmNhbGwoX2EsIFwidG9hc3RcIiwgb3B0cyk7XG4gICAgcmV0dXJuIGRpc21pc3M7XG4gIH1cbiAgcHJvZ3Jlc3Mob3B0cykge1xuICAgIHJldHVybiB0aGlzLmVsLnByb2dyZXNzKG9wdHMpO1xuICB9XG59O1xuXG5leHBvcnQgeyBBbGVydE1hbmFnZXIsIFhUb2FzdHMgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcFxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIiwiaW1wb3J0IHsgUGFnZU1hbmFnZXIgfSBmcm9tICdAY29udGVuaXIvcGFnZSc7XG5pbXBvcnQgJ0Bjb250ZW5pci9jb21wb25lbnRzJztcbmltcG9ydCAnQGNvbnRlbmlyL3VpJztcblxuZnVuY3Rpb24ga2lja29mZkVudGVyVHJhbnNpdGlvbihhcHApe1xuICBhcHAuY2xhc3NMaXN0LnJlbW92ZSgnaXMtZW50ZXJlZCcpO1xuICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoKCkgPT4gYXBwLmNsYXNzTGlzdC5hZGQoJ2lzLWVudGVyZWQnKSk7XG59XG5cbmZ1bmN0aW9uIGJvb3QoKXtcbiAgY29uc3QgYXBwID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcignI2FwcCcpO1xuICBpZiAoIWFwcCkgcmV0dXJuO1xuXG4gIC8vIEluaXRpYWwgbW91bnQgb25jZVxuICBraWNrb2ZmRW50ZXJUcmFuc2l0aW9uKGFwcCk7XG5cbiAgLy8gRXhhbXBsZSByb3V0ZXIgLyBQYWdlTWFuYWdlciB3aXJpbmdcbiAgY29uc3QgcGFnZU1hbmFnZXIgPSBuZXcgUGFnZU1hbmFnZXIoeyBjb250YWluZXI6IGFwcCB9KTtcblxuICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdldmVudDpyb3V0ZTpzdWNjZXNzJywgYXN5bmMgKGUpID0+IHtcbiAgICAvLyBvdXRcbiAgICBhcHAuY2xhc3NMaXN0LnJlbW92ZSgnaXMtZW50ZXJlZCcpO1xuICAgIC8vIHNtYWxsIGZyYW1lIHRvIGFsbG93IENTUyB0byBwaWNrIHVwIHN0YXRlIGNoYW5nZVxuICAgIGF3YWl0IG5ldyBQcm9taXNlKHIgPT4gcmVxdWVzdEFuaW1hdGlvbkZyYW1lKHIpKTtcblxuICAgIC8vIHJlbmRlciBuZXcgY29udGVudCAoYXNzdW1pbmcgUGFnZU1hbmFnZXIga25vd3MgaG93KVxuICAgIGF3YWl0IHBhZ2VNYW5hZ2VyLnJlbmRlcihlLmRldGFpbCk7XG5cbiAgICAvLyAocmUpbW91bnQgY29tcG9uZW50cyBpbiB0aGUgbmV3IERPTVxuICAgIHNhZmVNb3VudEFsbFdpdGhpbihhcHApO1xuXG4gICAgLy8gaW5cbiAgICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoKCkgPT4gYXBwLmNsYXNzTGlzdC5hZGQoJ2lzLWVudGVyZWQnKSk7XG4gIH0pO1xufVxuXG5kb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdET01Db250ZW50TG9hZGVkJywgYm9vdCk7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///35\n\n}')},944:()=>{eval("{// extracted by mini-css-extract-plugin\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiOTQ0LmpzIiwibWFwcGluZ3MiOiJBQUFBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vc3JjL3Njc3MvYmFzZS5zY3NzPzViNDQiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gZXh0cmFjdGVkIGJ5IG1pbmktY3NzLWV4dHJhY3QtcGx1Z2luXG5leHBvcnQge307Il0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///944\n\n}")}};__webpack_modules__[35]();var __webpack_exports__={};__webpack_modules__[944]()})();